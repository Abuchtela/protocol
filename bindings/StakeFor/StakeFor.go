// This file was generated by seer: https://github.com/moonstream-to/seer.
// seer version: 0.1.15
// seer command: seer evm generate --package StakeFor --cli --struct StakeFor --output bindings/StakeFor/StakeFor.go
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package StakeFor

import (
	"errors"
	"math/big"
	"strings"

	"context"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"

	// Reference imports to suppress errors if they are not otherwise used.
	"encoding/hex"
	"fmt"
	"os"
	"time"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/spf13/cobra"
	"golang.org/x/term"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// StakeForMetaData contains all meta data concerning the StakeFor contract.
var StakeForMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeERC20For\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561001057600080fd5b506001600081905550610562806100286000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c8063150b7a021461003b578063fc12772e1461006b575b600080fd5b6100556004803603810190610050919061030c565b61009b565b60405161006291906103cf565b60405180910390f35b610085600480360381019061008091906103ea565b6100b0565b6040516100929190610460565b60405180910390f35b600063150b7a0260e01b905095945050505050565b60006100ba6101b9565b8473ffffffffffffffffffffffffffffffffffffffff166337d9e9cc84846040518363ffffffff1660e01b81526004016100f592919061047b565b6020604051808303816000875af1158015610114573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013891906104b9565b90508473ffffffffffffffffffffffffffffffffffffffff166342842e0e3086846040518463ffffffff1660e01b8152600401610177939291906104f5565b600060405180830381600087803b15801561019157600080fd5b505af11580156101a5573d6000803e3d6000fd5b505050506101b16101ff565b949350505050565b6002600054036101f5576040517f3ee5aeb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600081905550565b6001600081905550565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061023e82610213565b9050919050565b61024e81610233565b811461025957600080fd5b50565b60008135905061026b81610245565b92915050565b6000819050919050565b61028481610271565b811461028f57600080fd5b50565b6000813590506102a18161027b565b92915050565b600080fd5b600080fd5b600080fd5b60008083601f8401126102cc576102cb6102a7565b5b8235905067ffffffffffffffff8111156102e9576102e86102ac565b5b602083019150836001820283011115610305576103046102b1565b5b9250929050565b60008060008060006080868803121561032857610327610209565b5b60006103368882890161025c565b95505060206103478882890161025c565b945050604061035888828901610292565b935050606086013567ffffffffffffffff8111156103795761037861020e565b5b610385888289016102b6565b92509250509295509295909350565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b6103c981610394565b82525050565b60006020820190506103e460008301846103c0565b92915050565b6000806000806080858703121561040457610403610209565b5b60006104128782880161025c565b94505060206104238782880161025c565b935050604061043487828801610292565b925050606061044587828801610292565b91505092959194509250565b61045a81610271565b82525050565b60006020820190506104756000830184610451565b92915050565b60006040820190506104906000830185610451565b61049d6020830184610451565b9392505050565b6000815190506104b38161027b565b92915050565b6000602082840312156104cf576104ce610209565b5b60006104dd848285016104a4565b91505092915050565b6104ef81610233565b82525050565b600060608201905061050a60008301866104e6565b61051760208301856104e6565b6105246040830184610451565b94935050505056fea2646970667358221220ae9ef482c706d6187d20f51b5741c25750fbe05c473fbd258c472c941c9dde0b64736f6c63430008180033",
}

// StakeForABI is the input ABI used to generate the binding from.
// Deprecated: Use StakeForMetaData.ABI instead.
var StakeForABI = StakeForMetaData.ABI

// StakeForBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use StakeForMetaData.Bin instead.
var StakeForBin = StakeForMetaData.Bin

// DeployStakeFor deploys a new Ethereum contract, binding an instance of StakeFor to it.
func DeployStakeFor(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *StakeFor, error) {
	parsed, err := StakeForMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(StakeForBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &StakeFor{StakeForCaller: StakeForCaller{contract: contract}, StakeForTransactor: StakeForTransactor{contract: contract}, StakeForFilterer: StakeForFilterer{contract: contract}}, nil
}

// StakeFor is an auto generated Go binding around an Ethereum contract.
type StakeFor struct {
	StakeForCaller     // Read-only binding to the contract
	StakeForTransactor // Write-only binding to the contract
	StakeForFilterer   // Log filterer for contract events
}

// StakeForCaller is an auto generated read-only Go binding around an Ethereum contract.
type StakeForCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakeForTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StakeForTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakeForFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StakeForFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakeForSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StakeForSession struct {
	Contract     *StakeFor         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StakeForCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StakeForCallerSession struct {
	Contract *StakeForCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// StakeForTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StakeForTransactorSession struct {
	Contract     *StakeForTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// StakeForRaw is an auto generated low-level Go binding around an Ethereum contract.
type StakeForRaw struct {
	Contract *StakeFor // Generic contract binding to access the raw methods on
}

// StakeForCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StakeForCallerRaw struct {
	Contract *StakeForCaller // Generic read-only contract binding to access the raw methods on
}

// StakeForTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StakeForTransactorRaw struct {
	Contract *StakeForTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStakeFor creates a new instance of StakeFor, bound to a specific deployed contract.
func NewStakeFor(address common.Address, backend bind.ContractBackend) (*StakeFor, error) {
	contract, err := bindStakeFor(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &StakeFor{StakeForCaller: StakeForCaller{contract: contract}, StakeForTransactor: StakeForTransactor{contract: contract}, StakeForFilterer: StakeForFilterer{contract: contract}}, nil
}

// NewStakeForCaller creates a new read-only instance of StakeFor, bound to a specific deployed contract.
func NewStakeForCaller(address common.Address, caller bind.ContractCaller) (*StakeForCaller, error) {
	contract, err := bindStakeFor(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StakeForCaller{contract: contract}, nil
}

// NewStakeForTransactor creates a new write-only instance of StakeFor, bound to a specific deployed contract.
func NewStakeForTransactor(address common.Address, transactor bind.ContractTransactor) (*StakeForTransactor, error) {
	contract, err := bindStakeFor(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StakeForTransactor{contract: contract}, nil
}

// NewStakeForFilterer creates a new log filterer instance of StakeFor, bound to a specific deployed contract.
func NewStakeForFilterer(address common.Address, filterer bind.ContractFilterer) (*StakeForFilterer, error) {
	contract, err := bindStakeFor(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StakeForFilterer{contract: contract}, nil
}

// bindStakeFor binds a generic wrapper to an already deployed contract.
func bindStakeFor(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := StakeForMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_StakeFor *StakeForRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _StakeFor.Contract.StakeForCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_StakeFor *StakeForRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _StakeFor.Contract.StakeForTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_StakeFor *StakeForRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _StakeFor.Contract.StakeForTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_StakeFor *StakeForCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _StakeFor.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_StakeFor *StakeForTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _StakeFor.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_StakeFor *StakeForTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _StakeFor.Contract.contract.Transact(opts, method, params...)
}

// OnERC721Received is a free data retrieval call binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address , address , uint256 , bytes ) pure returns(bytes4)
func (_StakeFor *StakeForCaller) OnERC721Received(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	var out []interface{}
	err := _StakeFor.contract.Call(opts, &out, "onERC721Received", arg0, arg1, arg2, arg3)

	if err != nil {
		return *new([4]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([4]byte)).(*[4]byte)

	return out0, err

}

// OnERC721Received is a free data retrieval call binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address , address , uint256 , bytes ) pure returns(bytes4)
func (_StakeFor *StakeForSession) OnERC721Received(arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	return _StakeFor.Contract.OnERC721Received(&_StakeFor.CallOpts, arg0, arg1, arg2, arg3)
}

// OnERC721Received is a free data retrieval call binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address , address , uint256 , bytes ) pure returns(bytes4)
func (_StakeFor *StakeForCallerSession) OnERC721Received(arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	return _StakeFor.Contract.OnERC721Received(&_StakeFor.CallOpts, arg0, arg1, arg2, arg3)
}

// StakeERC20For is a paid mutator transaction binding the contract method 0xfc12772e.
//
// Solidity: function stakeERC20For(address stakerContract, address user, uint256 poolID, uint256 amount) returns(uint256 positionTokenID)
func (_StakeFor *StakeForTransactor) StakeERC20For(opts *bind.TransactOpts, stakerContract common.Address, user common.Address, poolID *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _StakeFor.contract.Transact(opts, "stakeERC20For", stakerContract, user, poolID, amount)
}

// StakeERC20For is a paid mutator transaction binding the contract method 0xfc12772e.
//
// Solidity: function stakeERC20For(address stakerContract, address user, uint256 poolID, uint256 amount) returns(uint256 positionTokenID)
func (_StakeFor *StakeForSession) StakeERC20For(stakerContract common.Address, user common.Address, poolID *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _StakeFor.Contract.StakeERC20For(&_StakeFor.TransactOpts, stakerContract, user, poolID, amount)
}

// StakeERC20For is a paid mutator transaction binding the contract method 0xfc12772e.
//
// Solidity: function stakeERC20For(address stakerContract, address user, uint256 poolID, uint256 amount) returns(uint256 positionTokenID)
func (_StakeFor *StakeForTransactorSession) StakeERC20For(stakerContract common.Address, user common.Address, poolID *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _StakeFor.Contract.StakeERC20For(&_StakeFor.TransactOpts, stakerContract, user, poolID, amount)
}

func CreateStakeForDeploymentCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint

	cmd := &cobra.Command{
		Use:   "deploy",
		Short: "Deploy a new StakeFor contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			address, deploymentTransaction, _, deploymentErr := DeployStakeFor(
				transactionOpts,
				client,
			)
			if deploymentErr != nil {
				return deploymentErr
			}

			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					Data: deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")

	return cmd
}

func CreateOnErc721ReceivedCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 common.Address
	var arg0Raw string
	var arg1 common.Address
	var arg1Raw string
	var arg2 *big.Int
	var arg2Raw string
	var arg3 []byte
	var arg3Raw string

	var capture0 [4]byte

	cmd := &cobra.Command{
		Use:   "on-erc-721-received",
		Short: "Call the OnERC721Received view method on a StakeFor contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			} else if !common.IsHexAddress(arg0Raw) {
				return fmt.Errorf("--arg-0 argument is not a valid Ethereum address")
			}
			arg0 = common.HexToAddress(arg0Raw)

			if arg1Raw == "" {
				return fmt.Errorf("--arg-1 argument not specified")
			} else if !common.IsHexAddress(arg1Raw) {
				return fmt.Errorf("--arg-1 argument is not a valid Ethereum address")
			}
			arg1 = common.HexToAddress(arg1Raw)

			if arg2Raw == "" {
				return fmt.Errorf("--arg-2 argument not specified")
			}
			arg2 = new(big.Int)
			arg2.SetString(arg2Raw, 0)

			var arg3Intermediate []byte

			var arg3IntermediateHexDecodeErr error
			arg3Intermediate, arg3IntermediateHexDecodeErr = hex.DecodeString(arg3Raw)
			if arg3IntermediateHexDecodeErr != nil {
				return arg3IntermediateHexDecodeErr
			}

			copy(arg3[:], arg3Intermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStakeFor(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakeForCallerSession{
				Contract: &contract.StakeForCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.OnERC721Received(
				arg0,
				arg1,
				arg2,
				arg3,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument (common.Address)")
	cmd.Flags().StringVar(&arg1Raw, "arg-1", "", "arg-1 argument (common.Address)")
	cmd.Flags().StringVar(&arg2Raw, "arg-2", "", "arg-2 argument")
	cmd.Flags().StringVar(&arg3Raw, "arg-3", "", "arg-3 argument ([]byte)")

	return cmd
}

func CreateStakeErc20ForCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var stakerContract common.Address
	var stakerContractRaw string
	var user common.Address
	var userRaw string
	var poolID *big.Int
	var poolIDRaw string
	var amount *big.Int
	var amountRaw string

	cmd := &cobra.Command{
		Use:   "stake-erc-20-for",
		Short: "Execute the StakeERC20For method on a StakeFor contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if stakerContractRaw == "" {
				return fmt.Errorf("--staker-contract argument not specified")
			} else if !common.IsHexAddress(stakerContractRaw) {
				return fmt.Errorf("--staker-contract argument is not a valid Ethereum address")
			}
			stakerContract = common.HexToAddress(stakerContractRaw)

			if userRaw == "" {
				return fmt.Errorf("--user argument not specified")
			} else if !common.IsHexAddress(userRaw) {
				return fmt.Errorf("--user argument is not a valid Ethereum address")
			}
			user = common.HexToAddress(userRaw)

			if poolIDRaw == "" {
				return fmt.Errorf("--pool-id argument not specified")
			}
			poolID = new(big.Int)
			poolID.SetString(poolIDRaw, 0)

			if amountRaw == "" {
				return fmt.Errorf("--amount argument not specified")
			}
			amount = new(big.Int)
			amount.SetString(amountRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStakeFor(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakeForTransactorSession{
				Contract:     &contract.StakeForTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.StakeERC20For(
				stakerContract,
				user,
				poolID,
				amount,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&stakerContractRaw, "staker-contract", "", "staker-contract argument (common.Address)")
	cmd.Flags().StringVar(&userRaw, "user", "", "user argument (common.Address)")
	cmd.Flags().StringVar(&poolIDRaw, "pool-id", "", "pool-id argument")
	cmd.Flags().StringVar(&amountRaw, "amount", "", "amount argument")

	return cmd
}

var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the STAKE_FOR_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the STAKE_FOR_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("STAKE_FOR_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func CreateStakeForCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "stake-for",
		Short: "Interact with the StakeFor contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	cmdDeployStakeFor := CreateStakeForDeploymentCommand()
	cmdDeployStakeFor.GroupID = DeployGroup.ID
	cmd.AddCommand(cmdDeployStakeFor)

	cmdViewOnERC721Received := CreateOnErc721ReceivedCommand()
	cmdViewOnERC721Received.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewOnERC721Received)

	cmdTransactStakeERC20For := CreateStakeErc20ForCommand()
	cmdTransactStakeERC20For.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactStakeERC20For)

	return cmd
}
