// This file was generated by seer: https://github.com/G7DAO/seer.
// seer version: 0.3.0
// seer command: seer evm generate --package PositionMetadata --cli --struct PositionMetadata --output bindings/PositionMetadata/PositionMetadata.go
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package PositionMetadata

import (
	"bytes"
	"crypto/rand"
	"errors"
	"math/big"
	"net/http"
	"strings"

	"context"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/ethereum/go-ethereum/signer/core/apitypes"

	// Reference imports to suppress errors if they are not otherwise used.
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/G7DAO/seer/bindings/CreateCall"
	"github.com/G7DAO/seer/bindings/GnosisSafe"
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/spf13/cobra"
	"golang.org/x/term"

	// Position is an auto generated low-level Go binding around an user-defined struct.
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/crypto"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

type Position struct {
	PoolID             *big.Int
	AmountOrTokenID    *big.Int
	StakeTimestamp     *big.Int
	UnstakeInitiatedAt *big.Int
}

// StakingPool is an auto generated low-level Go binding around an user-defined struct.
type StakingPool struct {
	Administrator   common.Address
	TokenType       *big.Int
	TokenAddress    common.Address
	TokenID         *big.Int
	Transferable    bool
	LockupSeconds   *big.Int
	CooldownSeconds *big.Int
}

// PositionMetadataMetaData contains all meta data concerning the PositionMetadata contract.
var PositionMetadataMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeInitiatedAt\",\"type\":\"uint256\"}],\"internalType\":\"structPosition\",\"name\":\"position\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structStakingPool\",\"name\":\"pool\",\"type\":\"tuple\"}],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeInitiatedAt\",\"type\":\"uint256\"}],\"internalType\":\"structPosition\",\"name\":\"position\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structStakingPool\",\"name\":\"pool\",\"type\":\"tuple\"}],\"name\":\"metadataBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeInitiatedAt\",\"type\":\"uint256\"}],\"internalType\":\"structPosition\",\"name\":\"position\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structStakingPool\",\"name\":\"pool\",\"type\":\"tuple\"}],\"name\":\"metadataJSON\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561001057600080fd5b50610d86806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063239bdf6c14610046578063721ac18a1461006f5780637b2f34ff14610082575b600080fd5b610059610054366004610665565b610095565b60405161006691906107f4565b60405180910390f35b61005961007d366004610665565b6100aa565b610059610090366004610665565b610235565b60606100a28484846100aa565b949350505050565b606060006100b785610272565b6040516020016100c7919061080e565b6040516020818303038152906040529050806100e68560000151610272565b6040516020016100f79291906108ec565b60405160208183030381529060405290508083602001516102d11461013457604051806060016040528060278152602001610d2a6027913961014e565b604051806060016040528060298152602001610d01602991395b61015b8660200151610272565b60405160200161016d93929190610995565b60405160208183030381529060405290508061018c8560400151610272565b60405160200161019d929190610a2e565b6040516020818303038152906040529050806101cb8460a0015186604001516101c69190610b06565b610272565b6040516020016101dc929190610b19565b6040516020818303038152906040529050806040516020016101fe9190610be8565b604080518083037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001815291905295945050505050565b606061024a6102458585856100aa565b610330565b60405160200161025a9190610c29565b60405160208183030381529060405290509392505050565b6060600061027f83610490565b600101905060008167ffffffffffffffff81111561029f5761029f610573565b6040519080825280601f01601f1916602001820160405280156102c9576020820181803683370190505b5090508181016020015b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a85049450846102d357509392505050565b6060815160000361034f57505060408051602081019091526000815290565b6000604051806060016040528060408152602001610cc1604091399050600060038451600261037e9190610b06565b6103889190610c6e565b610393906004610ca9565b67ffffffffffffffff8111156103ab576103ab610573565b6040519080825280601f01601f1916602001820160405280156103d5576020820181803683370190505b50905060018201602082018586518701602081018051600082525b8284101561044b576003840193508351603f8160121c168701518653600186019550603f81600c1c168701518653600186019550603f8160061c168701518653600186019550603f81168701518653506001850194506103f0565b905250508551600390066001811461046a576002811461047d57610485565b603d6001830353603d6002830353610485565b603d60018303535b509195945050505050565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f01000000000000000083106104d9577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef81000000008310610505576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc10000831061052357662386f26fc10000830492506010015b6305f5e100831061053b576305f5e100830492506008015b612710831061054f57612710830492506004015b60648310610561576064830492506002015b600a831061056d576001015b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516080810167ffffffffffffffff811182821017156105ec577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405290565b60405160e0810167ffffffffffffffff811182821017156105ec577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b803573ffffffffffffffffffffffffffffffffffffffff8116811461066057600080fd5b919050565b600080600083850361018081121561067c57600080fd5b8435935060807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0820112156106b057600080fd5b6106b86105a2565b602086013581526040860135602082015260608601356040820152608086013560608201528093505060e07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff608201121561071157600080fd5b5061071a6105f2565b61072660a0860161063c565b815260c0850135602082015261073e60e0860161063c565b60408201526101008501356060820152610120850135801515811461076257600080fd5b608082015261014085013560a08201526101609094013560c0850152509093909250565b60005b838110156107a1578181015183820152602001610789565b50506000910152565b600081518084526107c2816020860160208601610786565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60208152600061080760208301846107aa565b9392505050565b7f7b22746f6b656e5f6964223a220000000000000000000000000000000000000081526000825161084681600d850160208701610786565b7f222c22696d616765223a202268747470733a2f2f6261646765732e6d6f6f6e73600d9390910192830152507f747265616d2e746f2f746573742f7374616b696e675f6c6f676f2e706e672200602d8201527f2c22726573756c745f76657273696f6e223a312c226174747269627574657322604c8201527f3a205b0000000000000000000000000000000000000000000000000000000000606c820152606f01919050565b600083516108fe818460208801610786565b80830190507f7b2274726169745f74797065223a22506f6f6c204944222c2276616c7565223a81527f22000000000000000000000000000000000000000000000000000000000000006020820152835161095f816021840160208801610786565b7f227d00000000000000000000000000000000000000000000000000000000000060219290910191820152602301949350505050565b600084516109a7818460208901610786565b7f2c0000000000000000000000000000000000000000000000000000000000000090830190815284516109e1816001840160208901610786565b84519101906109f7816001840160208801610786565b7f227d0000000000000000000000000000000000000000000000000000000000006001929091019182015260030195945050505050565b60008351610a40818460208801610786565b80830190507f2c7b22646973706c61795f74797065223a226e756d626572222c22747261697481527f5f74797065223a225374616b6564206174222c2276616c7565223a000000000060208201528351610aa181603b840160208801610786565b7f7d00000000000000000000000000000000000000000000000000000000000000603b9290910191820152603c01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561056d5761056d610ad7565b60008351610b2b818460208801610786565b80830190507f2c7b22646973706c61795f74797065223a226e756d626572222c22747261697481527f5f74797065223a224c6f636b75702065787069726573206174222c2276616c7560208201527f65223a000000000000000000000000000000000000000000000000000000000060408201528351610bb2816043840160208801610786565b7f7d0000000000000000000000000000000000000000000000000000000000000060439290910191820152604401949350505050565b60008251610bfa818460208701610786565b7f5d7d000000000000000000000000000000000000000000000000000000000000920191825250600201919050565b7f646174613a6170706c69636174696f6e2f6a736f6e3b6261736536342c000000815260008251610c6181601d850160208701610786565b91909101601d0192915050565b600082610ca4577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b808202811582820484141761056d5761056d610ad756fe4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392b2f7b2274726169745f74797065223a225374616b656420746f6b656e204944222c2276616c7565223a227b2274726169745f74797065223a225374616b656420616d6f756e74222c2276616c7565223a22a2646970667358221220765e718c273588624e90c593b93211f9d55db2a6b211d136e8f83d4d8ee6eb7264736f6c63430008180033",
}

// PositionMetadataABI is the input ABI used to generate the binding from.
// Deprecated: Use PositionMetadataMetaData.ABI instead.
var PositionMetadataABI = PositionMetadataMetaData.ABI

// PositionMetadataBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PositionMetadataMetaData.Bin instead.
var PositionMetadataBin = PositionMetadataMetaData.Bin

// DeployPositionMetadata deploys a new Ethereum contract, binding an instance of PositionMetadata to it.
func DeployPositionMetadata(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *PositionMetadata, error) {
	parsed, err := PositionMetadataMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PositionMetadataBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PositionMetadata{PositionMetadataCaller: PositionMetadataCaller{contract: contract}, PositionMetadataTransactor: PositionMetadataTransactor{contract: contract}, PositionMetadataFilterer: PositionMetadataFilterer{contract: contract}}, nil
}

// PositionMetadata is an auto generated Go binding around an Ethereum contract.
type PositionMetadata struct {
	PositionMetadataCaller     // Read-only binding to the contract
	PositionMetadataTransactor // Write-only binding to the contract
	PositionMetadataFilterer   // Log filterer for contract events
}

// PositionMetadataCaller is an auto generated read-only Go binding around an Ethereum contract.
type PositionMetadataCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionMetadataTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PositionMetadataTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionMetadataFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PositionMetadataFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionMetadataSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PositionMetadataSession struct {
	Contract     *PositionMetadata // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PositionMetadataCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PositionMetadataCallerSession struct {
	Contract *PositionMetadataCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// PositionMetadataTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PositionMetadataTransactorSession struct {
	Contract     *PositionMetadataTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// PositionMetadataRaw is an auto generated low-level Go binding around an Ethereum contract.
type PositionMetadataRaw struct {
	Contract *PositionMetadata // Generic contract binding to access the raw methods on
}

// PositionMetadataCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PositionMetadataCallerRaw struct {
	Contract *PositionMetadataCaller // Generic read-only contract binding to access the raw methods on
}

// PositionMetadataTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PositionMetadataTransactorRaw struct {
	Contract *PositionMetadataTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPositionMetadata creates a new instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadata(address common.Address, backend bind.ContractBackend) (*PositionMetadata, error) {
	contract, err := bindPositionMetadata(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PositionMetadata{PositionMetadataCaller: PositionMetadataCaller{contract: contract}, PositionMetadataTransactor: PositionMetadataTransactor{contract: contract}, PositionMetadataFilterer: PositionMetadataFilterer{contract: contract}}, nil
}

// NewPositionMetadataCaller creates a new read-only instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadataCaller(address common.Address, caller bind.ContractCaller) (*PositionMetadataCaller, error) {
	contract, err := bindPositionMetadata(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PositionMetadataCaller{contract: contract}, nil
}

// NewPositionMetadataTransactor creates a new write-only instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadataTransactor(address common.Address, transactor bind.ContractTransactor) (*PositionMetadataTransactor, error) {
	contract, err := bindPositionMetadata(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PositionMetadataTransactor{contract: contract}, nil
}

// NewPositionMetadataFilterer creates a new log filterer instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadataFilterer(address common.Address, filterer bind.ContractFilterer) (*PositionMetadataFilterer, error) {
	contract, err := bindPositionMetadata(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PositionMetadataFilterer{contract: contract}, nil
}

// bindPositionMetadata binds a generic wrapper to an already deployed contract.
func bindPositionMetadata(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PositionMetadataMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PositionMetadata *PositionMetadataRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PositionMetadata.Contract.PositionMetadataCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PositionMetadata *PositionMetadataRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PositionMetadata.Contract.PositionMetadataTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PositionMetadata *PositionMetadataRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PositionMetadata.Contract.PositionMetadataTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PositionMetadata *PositionMetadataCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PositionMetadata.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PositionMetadata *PositionMetadataTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PositionMetadata.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PositionMetadata *PositionMetadataTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PositionMetadata.Contract.contract.Transact(opts, method, params...)
}

// Metadata is a free data retrieval call binding the contract method 0x7b2f34ff.
//
// Solidity: function metadata(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataCaller) Metadata(opts *bind.CallOpts, positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	var out []interface{}
	err := _PositionMetadata.contract.Call(opts, &out, "metadata", positionTokenID, position, pool)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Metadata is a free data retrieval call binding the contract method 0x7b2f34ff.
//
// Solidity: function metadata(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataSession) Metadata(positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	return _PositionMetadata.Contract.Metadata(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

// Metadata is a free data retrieval call binding the contract method 0x7b2f34ff.
//
// Solidity: function metadata(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataCallerSession) Metadata(positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	return _PositionMetadata.Contract.Metadata(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

// MetadataBytes is a free data retrieval call binding the contract method 0x721ac18a.
//
// Solidity: function metadataBytes(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(bytes)
func (_PositionMetadata *PositionMetadataCaller) MetadataBytes(opts *bind.CallOpts, positionTokenID *big.Int, position Position, pool StakingPool) ([]byte, error) {
	var out []interface{}
	err := _PositionMetadata.contract.Call(opts, &out, "metadataBytes", positionTokenID, position, pool)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// MetadataBytes is a free data retrieval call binding the contract method 0x721ac18a.
//
// Solidity: function metadataBytes(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(bytes)
func (_PositionMetadata *PositionMetadataSession) MetadataBytes(positionTokenID *big.Int, position Position, pool StakingPool) ([]byte, error) {
	return _PositionMetadata.Contract.MetadataBytes(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

// MetadataBytes is a free data retrieval call binding the contract method 0x721ac18a.
//
// Solidity: function metadataBytes(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(bytes)
func (_PositionMetadata *PositionMetadataCallerSession) MetadataBytes(positionTokenID *big.Int, position Position, pool StakingPool) ([]byte, error) {
	return _PositionMetadata.Contract.MetadataBytes(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

// MetadataJSON is a free data retrieval call binding the contract method 0x239bdf6c.
//
// Solidity: function metadataJSON(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataCaller) MetadataJSON(opts *bind.CallOpts, positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	var out []interface{}
	err := _PositionMetadata.contract.Call(opts, &out, "metadataJSON", positionTokenID, position, pool)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// MetadataJSON is a free data retrieval call binding the contract method 0x239bdf6c.
//
// Solidity: function metadataJSON(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataSession) MetadataJSON(positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	return _PositionMetadata.Contract.MetadataJSON(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

// MetadataJSON is a free data retrieval call binding the contract method 0x239bdf6c.
//
// Solidity: function metadataJSON(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataCallerSession) MetadataJSON(positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	return _PositionMetadata.Contract.MetadataJSON(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

func CreatePositionMetadataDeploymentCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var safeAddress, safeApi, safeCreateCall, safeSaltRaw string
	var safeOperationType uint8
	var salt [32]byte
	var predictAddress bool

	cmd := &cobra.Command{
		Use:   "deploy",
		Short: "Deploy a new PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if safeCreateCall == "" {
					fmt.Println("--safe-create-call not specified, using default (0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4)")
					safeCreateCall = "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4"
				}
				if !common.IsHexAddress(safeCreateCall) {
					return fmt.Errorf("--safe-create-call is not a valid Ethereum address")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeSaltRaw == "" {
					fmt.Println("--safe-salt not specified, generating random salt")
					_, err := rand.Read(salt[:])
					if err != nil {
						return fmt.Errorf("failed to generate random salt: %v", err)
					}
					// prompt user to accept random salt
					fmt.Println("Generated salt:", common.Bytes2Hex(salt[:]))
					fmt.Println("Please check the salt and confirm (y/n)")
					var confirm string
					fmt.Scanln(&confirm)
					if confirm != "y" && confirm != "Y" && confirm != "\n" && confirm != "" {
						return fmt.Errorf("salt not accepted, please specify a valid salt")
					}
				} else {
					copy(salt[:], safeSaltRaw)
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			if safeAddress != "" {
				// Generate deploy bytecode with constructor arguments
				deployBytecode, err := generatePositionMetadataDeployBytecode()
				if err != nil {
					return fmt.Errorf("failed to generate deploy bytecode: %v", err)
				}

				// Create Safe proposal for deployment
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				if predictAddress {
					fmt.Println("Predicting deployment address...")
					from := common.HexToAddress(safeAddress)
					if safeOperationType == 0 {
						from = common.HexToAddress(safeCreateCall)
					}
					deploymentAddress, err := PredictDeploymentAddressSafe(from, salt, deployBytecode)
					if err != nil {
						return fmt.Errorf("failed to predict deployment address: %v", err)
					}
					fmt.Println("Predicted deployment address:", deploymentAddress.Hex())
					return nil
				} else {
					fmt.Println("Creating Safe proposal...")
					err = DeployWithSafe(client, key, common.HexToAddress(safeAddress), common.HexToAddress(safeCreateCall), value, safeApi, deployBytecode, SafeOperationType(safeOperationType), salt)
					if err != nil {
						return fmt.Errorf("failed to create Safe proposal: %v", err)
					}
				}

				return nil
			}

			address, deploymentTransaction, _, deploymentErr := DeployPositionMetadata(
				transactionOpts,
				client,
			)
			if deploymentErr != nil {
				return deploymentErr
			}

			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					Data: deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().StringVar(&safeCreateCall, "safe-create-call", "", "Address of the CreateCall contract (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 1, "Safe operation type: 0 (Call) or 1 (DelegateCall) - default is 1")
	cmd.Flags().StringVar(&safeSaltRaw, "safe-salt", "", "Salt to use for the Safe transaction")
	cmd.Flags().BoolVar(&predictAddress, "safe-predict-address", false, "Predict the deployment address (only works for Safe transactions)")

	return cmd
}

func generatePositionMetadataDeployBytecode() ([]byte, error) {
	abiPacked, err := PositionMetadataMetaData.GetAbi()
	if err != nil {
		return nil, fmt.Errorf("failed to get ABI: %v", err)
	}

	constructorArguments, err := abiPacked.Pack("")
	if err != nil {
		return nil, fmt.Errorf("failed to pack constructor arguments: %v", err)
	}

	deployBytecode := append(common.FromHex(PositionMetadataMetaData.Bin), constructorArguments...)
	return deployBytecode, nil
}

func CreateMetadataCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var positionTokenID *big.Int
	var positionTokenIDRaw string
	var position Position
	var positionRaw string
	var pool StakingPool
	var poolRaw string

	var capture0 string

	cmd := &cobra.Command{
		Use:   "metadata",
		Short: "Call the Metadata view method on a PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			if positionRaw == "" {
				return fmt.Errorf("--position argument not specified")
			} else if strings.HasPrefix(positionRaw, "@") {
				filename := strings.TrimPrefix(positionRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(positionRaw), &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if poolRaw == "" {
				return fmt.Errorf("--pool argument not specified")
			} else if strings.HasPrefix(poolRaw, "@") {
				filename := strings.TrimPrefix(poolRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(poolRaw), &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewPositionMetadata(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := PositionMetadataCallerSession{
				Contract: &contract.PositionMetadataCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Metadata(
				positionTokenID,
				position,
				pool,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")
	cmd.Flags().StringVar(&positionRaw, "position", "", "position argument (Position)")
	cmd.Flags().StringVar(&poolRaw, "pool", "", "pool argument (StakingPool)")

	return cmd
}
func CreateMetadataBytesCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var positionTokenID *big.Int
	var positionTokenIDRaw string
	var position Position
	var positionRaw string
	var pool StakingPool
	var poolRaw string

	var capture0 []byte

	cmd := &cobra.Command{
		Use:   "metadata-bytes",
		Short: "Call the MetadataBytes view method on a PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			if positionRaw == "" {
				return fmt.Errorf("--position argument not specified")
			} else if strings.HasPrefix(positionRaw, "@") {
				filename := strings.TrimPrefix(positionRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(positionRaw), &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if poolRaw == "" {
				return fmt.Errorf("--pool argument not specified")
			} else if strings.HasPrefix(poolRaw, "@") {
				filename := strings.TrimPrefix(poolRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(poolRaw), &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewPositionMetadata(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := PositionMetadataCallerSession{
				Contract: &contract.PositionMetadataCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.MetadataBytes(
				positionTokenID,
				position,
				pool,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")
	cmd.Flags().StringVar(&positionRaw, "position", "", "position argument (Position)")
	cmd.Flags().StringVar(&poolRaw, "pool", "", "pool argument (StakingPool)")

	return cmd
}
func CreateMetadataJsonCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var positionTokenID *big.Int
	var positionTokenIDRaw string
	var position Position
	var positionRaw string
	var pool StakingPool
	var poolRaw string

	var capture0 string

	cmd := &cobra.Command{
		Use:   "metadata-json",
		Short: "Call the MetadataJSON view method on a PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			if positionRaw == "" {
				return fmt.Errorf("--position argument not specified")
			} else if strings.HasPrefix(positionRaw, "@") {
				filename := strings.TrimPrefix(positionRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(positionRaw), &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if poolRaw == "" {
				return fmt.Errorf("--pool argument not specified")
			} else if strings.HasPrefix(poolRaw, "@") {
				filename := strings.TrimPrefix(poolRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(poolRaw), &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewPositionMetadata(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := PositionMetadataCallerSession{
				Contract: &contract.PositionMetadataCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.MetadataJSON(
				positionTokenID,
				position,
				pool,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")
	cmd.Flags().StringVar(&positionRaw, "position", "", "position argument (Position)")
	cmd.Flags().StringVar(&poolRaw, "pool", "", "pool argument (StakingPool)")

	return cmd
}

var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the POSITION_METADATA_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the POSITION_METADATA_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("POSITION_METADATA_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func CreatePositionMetadataCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "position-metadata",
		Short: "Interact with the PositionMetadata contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	cmdDeployPositionMetadata := CreatePositionMetadataDeploymentCommand()
	cmdDeployPositionMetadata.GroupID = DeployGroup.ID
	cmd.AddCommand(cmdDeployPositionMetadata)

	cmdViewMetadata := CreateMetadataCommand()
	cmdViewMetadata.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewMetadata)
	cmdViewMetadataBytes := CreateMetadataBytesCommand()
	cmdViewMetadataBytes.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewMetadataBytes)
	cmdViewMetadataJSON := CreateMetadataJsonCommand()
	cmdViewMetadataJSON.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewMetadataJSON)

	return cmd
}

// SafeOperationType represents the type of operation for a Safe transaction
type SafeOperationType uint8

const (
	Call         SafeOperationType = 0
	DelegateCall SafeOperationType = 1
)

// String returns the string representation of the SafeOperationType
func (o SafeOperationType) String() string {
	switch o {
	case Call:
		return "Call"
	case DelegateCall:
		return "DelegateCall"
	default:
		return "Unknown"
	}
}

// SafeTransactionData represents the data for a Safe transaction
type SafeTransactionData struct {
	To             string            `json:"to"`
	Value          string            `json:"value"`
	Data           string            `json:"data"`
	Operation      SafeOperationType `json:"operation"`
	SafeTxGas      uint64            `json:"safeTxGas"`
	BaseGas        uint64            `json:"baseGas"`
	GasPrice       string            `json:"gasPrice"`
	GasToken       string            `json:"gasToken"`
	RefundReceiver string            `json:"refundReceiver"`
	Nonce          uint64            `json:"nonce"`
	SafeTxHash     string            `json:"safeTxHash"`
	Sender         string            `json:"sender"`
	Signature      string            `json:"signature"`
	Origin         string            `json:"origin"`
}

const (
	NativeTokenAddress = "0x0000000000000000000000000000000000000000"
)

func DeployWithSafe(client *ethclient.Client, key *keystore.Key, safeAddress common.Address, factoryAddress common.Address, value *big.Int, safeApi string, deployBytecode []byte, safeOperationType SafeOperationType, salt [32]byte) error {
	abi, err := CreateCall.CreateCallMetaData.GetAbi()
	if err != nil {
		return fmt.Errorf("failed to get ABI: %v", err)
	}

	safeCreateCallTxData, err := abi.Pack("performCreate2", value, deployBytecode, salt)
	if err != nil {
		return fmt.Errorf("failed to pack performCreate2 transaction: %v", err)
	}

	return CreateSafeProposal(client, key, safeAddress, factoryAddress, safeCreateCallTxData, value, safeApi, SafeOperationType(safeOperationType))
}

func PredictDeploymentAddressSafe(from common.Address, salt [32]byte, deployBytecode []byte) (common.Address, error) {
	// Calculate the hash of the init code (deployment bytecode)
	initCodeHash := crypto.Keccak256(deployBytecode)

	// Calculate the CREATE2 address
	deployedAddress := crypto.CreateAddress2(from, salt, initCodeHash)

	return deployedAddress, nil
}

func CreateSafeProposal(client *ethclient.Client, key *keystore.Key, safeAddress common.Address, to common.Address, data []byte, value *big.Int, safeApi string, safeOperationType SafeOperationType) error {
	chainID, err := client.ChainID(context.Background())
	if err != nil {
		return fmt.Errorf("failed to get chain ID: %v", err)
	}

	// Create a new instance of the GnosisSafe contract
	safeInstance, err := GnosisSafe.NewGnosisSafe(safeAddress, client)
	if err != nil {
		return fmt.Errorf("failed to create GnosisSafe instance: %v", err)
	}

	// Fetch the current nonce from the Safe contract
	nonce, err := safeInstance.Nonce(&bind.CallOpts{})
	if err != nil {
		return fmt.Errorf("failed to fetch nonce from Safe contract: %v", err)
	}

	safeTransactionData := SafeTransactionData{
		To:             to.Hex(),
		Value:          value.String(),
		Data:           common.Bytes2Hex(data),
		Operation:      safeOperationType,
		SafeTxGas:      0,
		BaseGas:        0,
		GasPrice:       "0",
		GasToken:       NativeTokenAddress,
		RefundReceiver: NativeTokenAddress,
		Nonce:          nonce.Uint64(),
	}

	// Calculate SafeTxHash
	safeTxHash, err := CalculateSafeTxHash(safeAddress, safeTransactionData, chainID)
	if err != nil {
		return fmt.Errorf("failed to calculate SafeTxHash: %v", err)
	}

	// Sign the SafeTxHash
	signature, err := crypto.Sign(safeTxHash.Bytes(), key.PrivateKey)
	if err != nil {
		return fmt.Errorf("failed to sign SafeTxHash: %v", err)
	}

	// Adjust V value for Ethereum's replay protection
	signature[64] += 27

	// Convert signature to hex
	senderSignature := "0x" + common.Bytes2Hex(signature)

	// Prepare the request body
	requestBody := map[string]interface{}{
		"to":             safeTransactionData.To,
		"value":          safeTransactionData.Value,
		"data":           "0x" + safeTransactionData.Data,
		"operation":      int(safeTransactionData.Operation),
		"safeTxGas":      fmt.Sprintf("%d", safeTransactionData.SafeTxGas),
		"baseGas":        fmt.Sprintf("%d", safeTransactionData.BaseGas),
		"gasPrice":       safeTransactionData.GasPrice,
		"gasToken":       safeTransactionData.GasToken,
		"refundReceiver": safeTransactionData.RefundReceiver,
		"nonce":          fmt.Sprintf("%d", safeTransactionData.Nonce),
		"safeTxHash":     safeTxHash.Hex(),
		"sender":         key.Address.Hex(),
		"signature":      senderSignature,
		"origin":         fmt.Sprintf("{\"url\":\"%s\",\"name\":\"TokenSender Deployment\"}", safeApi),
	}

	// Marshal the request body to JSON
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %v", err)
	}

	// Send the request to the Safe Transaction Service
	req, err := http.NewRequest("POST", safeApi, bytes.NewBuffer(jsonBody))
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")

	httpClient := &http.Client{}
	resp, err := httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	fmt.Println("Safe proposal created successfully")
	return nil
}

func CalculateSafeTxHash(safeAddress common.Address, txData SafeTransactionData, chainID *big.Int) (common.Hash, error) {
	domainSeparator := apitypes.TypedDataDomain{
		ChainId:           (*math.HexOrDecimal256)(chainID),
		VerifyingContract: safeAddress.Hex(),
	}

	typedData := apitypes.TypedData{
		Types: apitypes.Types{
			"EIP712Domain": []apitypes.Type{
				{Name: "chainId", Type: "uint256"},
				{Name: "verifyingContract", Type: "address"},
			},
			"SafeTx": []apitypes.Type{
				{Name: "to", Type: "address"},
				{Name: "value", Type: "uint256"},
				{Name: "data", Type: "bytes"},
				{Name: "operation", Type: "uint8"},
				{Name: "safeTxGas", Type: "uint256"},
				{Name: "baseGas", Type: "uint256"},
				{Name: "gasPrice", Type: "uint256"},
				{Name: "gasToken", Type: "address"},
				{Name: "refundReceiver", Type: "address"},
				{Name: "nonce", Type: "uint256"},
			},
		},
		Domain:      domainSeparator,
		PrimaryType: "SafeTx",
		Message: apitypes.TypedDataMessage{
			"to":             txData.To,
			"value":          txData.Value,
			"data":           "0x" + txData.Data,
			"operation":      fmt.Sprintf("%d", txData.Operation),
			"safeTxGas":      fmt.Sprintf("%d", txData.SafeTxGas),
			"baseGas":        fmt.Sprintf("%d", txData.BaseGas),
			"gasPrice":       txData.GasPrice,
			"gasToken":       txData.GasToken,
			"refundReceiver": txData.RefundReceiver,
			"nonce":          fmt.Sprintf("%d", txData.Nonce),
		},
	}

	typedDataHash, _, err := apitypes.TypedDataAndHash(typedData)
	if err != nil {
		return common.Hash{}, fmt.Errorf("failed to hash typed data: %v", err)
	}

	return common.BytesToHash(typedDataHash), nil
}
