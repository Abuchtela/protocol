// This file was generated by seer: https://github.com/moonstream-to/seer.
// seer version: 0.1.15
// seer command: seer evm generate --package PositionMetadata --cli --struct PositionMetadata --output bindings/PositionMetadata/PositionMetadata.go
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package PositionMetadata

import (
	"errors"
	"math/big"
	"strings"

	"context"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"

	// Reference imports to suppress errors if they are not otherwise used.
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/spf13/cobra"
	"golang.org/x/term"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// Position is an auto generated low-level Go binding around an user-defined struct.
type Position struct {
	PoolID             *big.Int
	AmountOrTokenID    *big.Int
	StakeTimestamp     *big.Int
	UnstakeInitiatedAt *big.Int
}

// StakingPool is an auto generated low-level Go binding around an user-defined struct.
type StakingPool struct {
	Administrator   common.Address
	TokenType       *big.Int
	TokenAddress    common.Address
	TokenID         *big.Int
	Transferable    bool
	LockupSeconds   *big.Int
	CooldownSeconds *big.Int
}

// PositionMetadataMetaData contains all meta data concerning the PositionMetadata contract.
var PositionMetadataMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structStakingPool\",\"name\":\"pool\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeInitiatedAt\",\"type\":\"uint256\"}],\"internalType\":\"structPosition\",\"name\":\"position\",\"type\":\"tuple\"}],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structStakingPool\",\"name\":\"pool\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeInitiatedAt\",\"type\":\"uint256\"}],\"internalType\":\"structPosition\",\"name\":\"position\",\"type\":\"tuple\"}],\"name\":\"metadataBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structStakingPool\",\"name\":\"pool\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeInitiatedAt\",\"type\":\"uint256\"}],\"internalType\":\"structPosition\",\"name\":\"position\",\"type\":\"tuple\"}],\"name\":\"metadataJSON\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561001057600080fd5b50611227806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80632a0ab0e8146100465780633fcb348b14610076578063c034b724146100a6575b600080fd5b610060600480360381019061005b91906108c9565b6100d6565b60405161006d91906109b2565b60405180910390f35b610090600480360381019061008b91906108c9565b610115565b60405161009d9190610a29565b60405180910390f35b6100c060048036038101906100bb91906108c9565b610286565b6040516100cd91906109b2565b60405180910390f35b60606100ec6100e786868686610115565b61029e565b6040516020016100fc9190610ad3565b6040516020818303038152906040529050949350505050565b6060600061012284610410565b6040516020016101329190610c25565b6040516020818303038152906040529050806101518460000151610410565b604051602001610162929190610d57565b6040516020818303038152906040529050806102d186602001511461019f576040518060600160405280602781526020016111cb602791396101b9565b6040518060600160405280602981526020016111a2602991395b6101c68560200151610410565b6040516020016101d893929190610ddd565b6040516020818303038152906040529050806101f78460400151610410565b604051602001610208929190610ee2565b6040516020818303038152906040529050806102368660a0015185604001516102319190610f4b565b610410565b604051602001610247929190611017565b604051602081830303815290604052905080604051602001610269919061109d565b604051602081830303815290604052905080915050949350505050565b606061029485858585610115565b9050949350505050565b606060008251036102c05760405180602001604052806000815250905061040b565b600060405180606001604052806040815260200161116260409139905060006003600285516102ef9190610f4b565b6102f991906110ee565b6004610305919061111f565b67ffffffffffffffff81111561031e5761031d61068c565b5b6040519080825280601f01601f1916602001820160405280156103505781602001600182028036833780820191505090505b50905060018201602082018586518701602081018051600082525b828410156103c6576003840193508351603f8160121c168701518653600186019550603f81600c1c168701518653600186019550603f8160061c168701518653600186019550603f811687015186536001860195505061036b565b80825260038a5106600181146103e357600281146103f6576103fe565b603d6001870353603d60028703536103fe565b603d60018703535b5050505050505080925050505b919050565b60606000600161041f846104de565b01905060008167ffffffffffffffff81111561043e5761043d61068c565b5b6040519080825280601f01601f1916602001820160405280156104705781602001600182028036833780820191505090505b509050600082602001820190505b6001156104d3578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a85816104c7576104c66110bf565b5b0494506000850361047e575b819350505050919050565b600080600090507a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000831061053c577a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008381610532576105316110bf565b5b0492506040810190505b6d04ee2d6d415b85acef81000000008310610579576d04ee2d6d415b85acef8100000000838161056f5761056e6110bf565b5b0492506020810190505b662386f26fc1000083106105a857662386f26fc10000838161059e5761059d6110bf565b5b0492506010810190505b6305f5e10083106105d1576305f5e10083816105c7576105c66110bf565b5b0492506008810190505b61271083106105f65761271083816105ec576105eb6110bf565b5b0492506004810190505b60648310610619576064838161060f5761060e6110bf565b5b0492506002810190505b600a8310610628576001810190505b80915050919050565b6000604051905090565b600080fd5b6000819050919050565b61065381610640565b811461065e57600080fd5b50565b6000813590506106708161064a565b92915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6106c48261067b565b810181811067ffffffffffffffff821117156106e3576106e261068c565b5b80604052505050565b60006106f6610631565b905061070282826106bb565b919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061073282610707565b9050919050565b61074281610727565b811461074d57600080fd5b50565b60008135905061075f81610739565b92915050565b60008115159050919050565b61077a81610765565b811461078557600080fd5b50565b60008135905061079781610771565b92915050565b600060e082840312156107b3576107b2610676565b5b6107bd60e06106ec565b905060006107cd84828501610750565b60008301525060206107e184828501610661565b60208301525060406107f584828501610750565b604083015250606061080984828501610661565b606083015250608061081d84828501610788565b60808301525060a061083184828501610661565b60a08301525060c061084584828501610661565b60c08301525092915050565b60006080828403121561086757610866610676565b5b61087160806106ec565b9050600061088184828501610661565b600083015250602061089584828501610661565b60208301525060406108a984828501610661565b60408301525060606108bd84828501610661565b60608301525092915050565b6000806000806101a085870312156108e4576108e361063b565b5b60006108f287828801610661565b94505060206109038782880161079d565b93505061010061091587828801610661565b92505061012061092787828801610851565b91505092959194509250565b600081519050919050565b600082825260208201905092915050565b60005b8381101561096d578082015181840152602081019050610952565b60008484015250505050565b600061098482610933565b61098e818561093e565b935061099e81856020860161094f565b6109a78161067b565b840191505092915050565b600060208201905081810360008301526109cc8184610979565b905092915050565b600081519050919050565b600082825260208201905092915050565b60006109fb826109d4565b610a0581856109df565b9350610a1581856020860161094f565b610a1e8161067b565b840191505092915050565b60006020820190508181036000830152610a4381846109f0565b905092915050565b600081905092915050565b7f646174613a6170706c69636174696f6e2f6a736f6e3b6261736536342c000000600082015250565b6000610a8c601d83610a4b565b9150610a9782610a56565b601d82019050919050565b6000610aad82610933565b610ab78185610a4b565b9350610ac781856020860161094f565b80840191505092915050565b6000610ade82610a7f565b9150610aea8284610aa2565b915081905092915050565b7f7b22746f6b656e5f6964223a2200000000000000000000000000000000000000600082015250565b6000610b2b600d83610a4b565b9150610b3682610af5565b600d82019050919050565b7f222c22696d616765223a202268747470733a2f2f6261646765732e6d6f6f6e7360008201527f747265616d2e746f2f746573742f7374616b696e675f6c6f676f2e706e672200602082015250565b6000610b9d603f83610a4b565b9150610ba882610b41565b603f82019050919050565b7f2c22726573756c745f76657273696f6e223a312c22617474726962757465732260008201527f3a205b0000000000000000000000000000000000000000000000000000000000602082015250565b6000610c0f602383610a4b565b9150610c1a82610bb3565b602382019050919050565b6000610c3082610b1e565b9150610c3c8284610aa2565b9150610c4782610b90565b9150610c5282610c02565b915081905092915050565b600081905092915050565b6000610c73826109d4565b610c7d8185610c5d565b9350610c8d81856020860161094f565b80840191505092915050565b7f7b2274726169745f74797065223a22506f6f6c204944222c2276616c7565223a60008201527f2200000000000000000000000000000000000000000000000000000000000000602082015250565b6000610cf5602183610a4b565b9150610d0082610c99565b602182019050919050565b7f227d000000000000000000000000000000000000000000000000000000000000600082015250565b6000610d41600283610a4b565b9150610d4c82610d0b565b600282019050919050565b6000610d638285610c68565b9150610d6e82610ce8565b9150610d7a8284610aa2565b9150610d8582610d34565b91508190509392505050565b7f2c00000000000000000000000000000000000000000000000000000000000000600082015250565b6000610dc7600183610a4b565b9150610dd282610d91565b600182019050919050565b6000610de98286610c68565b9150610df482610dba565b9150610e008285610aa2565b9150610e0c8284610aa2565b9150610e1782610d34565b9150819050949350505050565b7f2c7b22646973706c61795f74797065223a226e756d626572222c22747261697460008201527f5f74797065223a225374616b6564206174222c2276616c7565223a0000000000602082015250565b6000610e80603b83610a4b565b9150610e8b82610e24565b603b82019050919050565b7f7d00000000000000000000000000000000000000000000000000000000000000600082015250565b6000610ecc600183610a4b565b9150610ed782610e96565b600182019050919050565b6000610eee8285610c68565b9150610ef982610e73565b9150610f058284610aa2565b9150610f1082610ebf565b91508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610f5682610640565b9150610f6183610640565b9250828201905080821115610f7957610f78610f1c565b5b92915050565b7f2c7b22646973706c61795f74797065223a226e756d626572222c22747261697460008201527f5f74797065223a224c6f636b75702065787069726573206174222c2276616c7560208201527f65223a0000000000000000000000000000000000000000000000000000000000604082015250565b6000611001604383610a4b565b915061100c82610f7f565b604382019050919050565b60006110238285610c68565b915061102e82610ff4565b915061103a8284610aa2565b915061104582610ebf565b91508190509392505050565b7f5d7d000000000000000000000000000000000000000000000000000000000000600082015250565b6000611087600283610a4b565b915061109282611051565b600282019050919050565b60006110a98284610c68565b91506110b48261107a565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006110f982610640565b915061110483610640565b925082611114576111136110bf565b5b828204905092915050565b600061112a82610640565b915061113583610640565b925082820261114381610640565b9150828204841483151761115a57611159610f1c565b5b509291505056fe4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392b2f7b2274726169745f74797065223a225374616b656420746f6b656e204944222c2276616c7565223a227b2274726169745f74797065223a225374616b656420616d6f756e74222c2276616c7565223a22a26469706673582212208dc98b0ff747482f9c2e6e6502901246f7f29706d998c5282c75236fbf10cdfd64736f6c63430008180033",
}

// PositionMetadataABI is the input ABI used to generate the binding from.
// Deprecated: Use PositionMetadataMetaData.ABI instead.
var PositionMetadataABI = PositionMetadataMetaData.ABI

// PositionMetadataBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PositionMetadataMetaData.Bin instead.
var PositionMetadataBin = PositionMetadataMetaData.Bin

// DeployPositionMetadata deploys a new Ethereum contract, binding an instance of PositionMetadata to it.
func DeployPositionMetadata(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *PositionMetadata, error) {
	parsed, err := PositionMetadataMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PositionMetadataBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PositionMetadata{PositionMetadataCaller: PositionMetadataCaller{contract: contract}, PositionMetadataTransactor: PositionMetadataTransactor{contract: contract}, PositionMetadataFilterer: PositionMetadataFilterer{contract: contract}}, nil
}

// PositionMetadata is an auto generated Go binding around an Ethereum contract.
type PositionMetadata struct {
	PositionMetadataCaller     // Read-only binding to the contract
	PositionMetadataTransactor // Write-only binding to the contract
	PositionMetadataFilterer   // Log filterer for contract events
}

// PositionMetadataCaller is an auto generated read-only Go binding around an Ethereum contract.
type PositionMetadataCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionMetadataTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PositionMetadataTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionMetadataFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PositionMetadataFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionMetadataSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PositionMetadataSession struct {
	Contract     *PositionMetadata // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PositionMetadataCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PositionMetadataCallerSession struct {
	Contract *PositionMetadataCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// PositionMetadataTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PositionMetadataTransactorSession struct {
	Contract     *PositionMetadataTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// PositionMetadataRaw is an auto generated low-level Go binding around an Ethereum contract.
type PositionMetadataRaw struct {
	Contract *PositionMetadata // Generic contract binding to access the raw methods on
}

// PositionMetadataCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PositionMetadataCallerRaw struct {
	Contract *PositionMetadataCaller // Generic read-only contract binding to access the raw methods on
}

// PositionMetadataTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PositionMetadataTransactorRaw struct {
	Contract *PositionMetadataTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPositionMetadata creates a new instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadata(address common.Address, backend bind.ContractBackend) (*PositionMetadata, error) {
	contract, err := bindPositionMetadata(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PositionMetadata{PositionMetadataCaller: PositionMetadataCaller{contract: contract}, PositionMetadataTransactor: PositionMetadataTransactor{contract: contract}, PositionMetadataFilterer: PositionMetadataFilterer{contract: contract}}, nil
}

// NewPositionMetadataCaller creates a new read-only instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadataCaller(address common.Address, caller bind.ContractCaller) (*PositionMetadataCaller, error) {
	contract, err := bindPositionMetadata(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PositionMetadataCaller{contract: contract}, nil
}

// NewPositionMetadataTransactor creates a new write-only instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadataTransactor(address common.Address, transactor bind.ContractTransactor) (*PositionMetadataTransactor, error) {
	contract, err := bindPositionMetadata(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PositionMetadataTransactor{contract: contract}, nil
}

// NewPositionMetadataFilterer creates a new log filterer instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadataFilterer(address common.Address, filterer bind.ContractFilterer) (*PositionMetadataFilterer, error) {
	contract, err := bindPositionMetadata(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PositionMetadataFilterer{contract: contract}, nil
}

// bindPositionMetadata binds a generic wrapper to an already deployed contract.
func bindPositionMetadata(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PositionMetadataMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PositionMetadata *PositionMetadataRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PositionMetadata.Contract.PositionMetadataCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PositionMetadata *PositionMetadataRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PositionMetadata.Contract.PositionMetadataTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PositionMetadata *PositionMetadataRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PositionMetadata.Contract.PositionMetadataTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PositionMetadata *PositionMetadataCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PositionMetadata.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PositionMetadata *PositionMetadataTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PositionMetadata.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PositionMetadata *PositionMetadataTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PositionMetadata.Contract.contract.Transact(opts, method, params...)
}

// Metadata is a free data retrieval call binding the contract method 0x2a0ab0e8.
//
// Solidity: function metadata(uint256 poolID, (address,uint256,address,uint256,bool,uint256,uint256) pool, uint256 positionTokenID, (uint256,uint256,uint256,uint256) position) pure returns(string)
func (_PositionMetadata *PositionMetadataCaller) Metadata(opts *bind.CallOpts, poolID *big.Int, pool StakingPool, positionTokenID *big.Int, position Position) (string, error) {
	var out []interface{}
	err := _PositionMetadata.contract.Call(opts, &out, "metadata", poolID, pool, positionTokenID, position)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Metadata is a free data retrieval call binding the contract method 0x2a0ab0e8.
//
// Solidity: function metadata(uint256 poolID, (address,uint256,address,uint256,bool,uint256,uint256) pool, uint256 positionTokenID, (uint256,uint256,uint256,uint256) position) pure returns(string)
func (_PositionMetadata *PositionMetadataSession) Metadata(poolID *big.Int, pool StakingPool, positionTokenID *big.Int, position Position) (string, error) {
	return _PositionMetadata.Contract.Metadata(&_PositionMetadata.CallOpts, poolID, pool, positionTokenID, position)
}

// Metadata is a free data retrieval call binding the contract method 0x2a0ab0e8.
//
// Solidity: function metadata(uint256 poolID, (address,uint256,address,uint256,bool,uint256,uint256) pool, uint256 positionTokenID, (uint256,uint256,uint256,uint256) position) pure returns(string)
func (_PositionMetadata *PositionMetadataCallerSession) Metadata(poolID *big.Int, pool StakingPool, positionTokenID *big.Int, position Position) (string, error) {
	return _PositionMetadata.Contract.Metadata(&_PositionMetadata.CallOpts, poolID, pool, positionTokenID, position)
}

// MetadataBytes is a free data retrieval call binding the contract method 0x3fcb348b.
//
// Solidity: function metadataBytes(uint256 , (address,uint256,address,uint256,bool,uint256,uint256) pool, uint256 positionTokenID, (uint256,uint256,uint256,uint256) position) pure returns(bytes)
func (_PositionMetadata *PositionMetadataCaller) MetadataBytes(opts *bind.CallOpts, arg0 *big.Int, pool StakingPool, positionTokenID *big.Int, position Position) ([]byte, error) {
	var out []interface{}
	err := _PositionMetadata.contract.Call(opts, &out, "metadataBytes", arg0, pool, positionTokenID, position)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// MetadataBytes is a free data retrieval call binding the contract method 0x3fcb348b.
//
// Solidity: function metadataBytes(uint256 , (address,uint256,address,uint256,bool,uint256,uint256) pool, uint256 positionTokenID, (uint256,uint256,uint256,uint256) position) pure returns(bytes)
func (_PositionMetadata *PositionMetadataSession) MetadataBytes(arg0 *big.Int, pool StakingPool, positionTokenID *big.Int, position Position) ([]byte, error) {
	return _PositionMetadata.Contract.MetadataBytes(&_PositionMetadata.CallOpts, arg0, pool, positionTokenID, position)
}

// MetadataBytes is a free data retrieval call binding the contract method 0x3fcb348b.
//
// Solidity: function metadataBytes(uint256 , (address,uint256,address,uint256,bool,uint256,uint256) pool, uint256 positionTokenID, (uint256,uint256,uint256,uint256) position) pure returns(bytes)
func (_PositionMetadata *PositionMetadataCallerSession) MetadataBytes(arg0 *big.Int, pool StakingPool, positionTokenID *big.Int, position Position) ([]byte, error) {
	return _PositionMetadata.Contract.MetadataBytes(&_PositionMetadata.CallOpts, arg0, pool, positionTokenID, position)
}

// MetadataJSON is a free data retrieval call binding the contract method 0xc034b724.
//
// Solidity: function metadataJSON(uint256 poolID, (address,uint256,address,uint256,bool,uint256,uint256) pool, uint256 positionTokenID, (uint256,uint256,uint256,uint256) position) pure returns(string)
func (_PositionMetadata *PositionMetadataCaller) MetadataJSON(opts *bind.CallOpts, poolID *big.Int, pool StakingPool, positionTokenID *big.Int, position Position) (string, error) {
	var out []interface{}
	err := _PositionMetadata.contract.Call(opts, &out, "metadataJSON", poolID, pool, positionTokenID, position)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// MetadataJSON is a free data retrieval call binding the contract method 0xc034b724.
//
// Solidity: function metadataJSON(uint256 poolID, (address,uint256,address,uint256,bool,uint256,uint256) pool, uint256 positionTokenID, (uint256,uint256,uint256,uint256) position) pure returns(string)
func (_PositionMetadata *PositionMetadataSession) MetadataJSON(poolID *big.Int, pool StakingPool, positionTokenID *big.Int, position Position) (string, error) {
	return _PositionMetadata.Contract.MetadataJSON(&_PositionMetadata.CallOpts, poolID, pool, positionTokenID, position)
}

// MetadataJSON is a free data retrieval call binding the contract method 0xc034b724.
//
// Solidity: function metadataJSON(uint256 poolID, (address,uint256,address,uint256,bool,uint256,uint256) pool, uint256 positionTokenID, (uint256,uint256,uint256,uint256) position) pure returns(string)
func (_PositionMetadata *PositionMetadataCallerSession) MetadataJSON(poolID *big.Int, pool StakingPool, positionTokenID *big.Int, position Position) (string, error) {
	return _PositionMetadata.Contract.MetadataJSON(&_PositionMetadata.CallOpts, poolID, pool, positionTokenID, position)
}

func CreatePositionMetadataDeploymentCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint

	cmd := &cobra.Command{
		Use:   "deploy",
		Short: "Deploy a new PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			address, deploymentTransaction, _, deploymentErr := DeployPositionMetadata(
				transactionOpts,
				client,
			)
			if deploymentErr != nil {
				return deploymentErr
			}

			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					Data: deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")

	return cmd
}

func CreateMetadataCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var poolID *big.Int
	var poolIDRaw string
	var pool StakingPool
	var poolRaw string
	var positionTokenID *big.Int
	var positionTokenIDRaw string
	var position Position
	var positionRaw string

	var capture0 string

	cmd := &cobra.Command{
		Use:   "metadata",
		Short: "Call the Metadata view method on a PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if poolIDRaw == "" {
				return fmt.Errorf("--pool-id argument not specified")
			}
			poolID = new(big.Int)
			poolID.SetString(poolIDRaw, 0)

			if poolRaw == "" {
				return fmt.Errorf("--pool argument not specified")
			} else if strings.HasPrefix(poolRaw, "@") {
				filename := strings.TrimPrefix(poolRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(poolRaw), &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			if positionRaw == "" {
				return fmt.Errorf("--position argument not specified")
			} else if strings.HasPrefix(positionRaw, "@") {
				filename := strings.TrimPrefix(positionRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(positionRaw), &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewPositionMetadata(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := PositionMetadataCallerSession{
				Contract: &contract.PositionMetadataCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Metadata(
				poolID,
				pool,
				positionTokenID,
				position,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&poolIDRaw, "pool-id", "", "pool-id argument")
	cmd.Flags().StringVar(&poolRaw, "pool", "", "pool argument (StakingPool)")
	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")
	cmd.Flags().StringVar(&positionRaw, "position", "", "position argument (Position)")

	return cmd
}
func CreateMetadataBytesCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 *big.Int
	var arg0Raw string
	var pool StakingPool
	var poolRaw string
	var positionTokenID *big.Int
	var positionTokenIDRaw string
	var position Position
	var positionRaw string

	var capture0 []byte

	cmd := &cobra.Command{
		Use:   "metadata-bytes",
		Short: "Call the MetadataBytes view method on a PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			}
			arg0 = new(big.Int)
			arg0.SetString(arg0Raw, 0)

			if poolRaw == "" {
				return fmt.Errorf("--pool argument not specified")
			} else if strings.HasPrefix(poolRaw, "@") {
				filename := strings.TrimPrefix(poolRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(poolRaw), &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			if positionRaw == "" {
				return fmt.Errorf("--position argument not specified")
			} else if strings.HasPrefix(positionRaw, "@") {
				filename := strings.TrimPrefix(positionRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(positionRaw), &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewPositionMetadata(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := PositionMetadataCallerSession{
				Contract: &contract.PositionMetadataCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.MetadataBytes(
				arg0,
				pool,
				positionTokenID,
				position,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument")
	cmd.Flags().StringVar(&poolRaw, "pool", "", "pool argument (StakingPool)")
	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")
	cmd.Flags().StringVar(&positionRaw, "position", "", "position argument (Position)")

	return cmd
}
func CreateMetadataJsonCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var poolID *big.Int
	var poolIDRaw string
	var pool StakingPool
	var poolRaw string
	var positionTokenID *big.Int
	var positionTokenIDRaw string
	var position Position
	var positionRaw string

	var capture0 string

	cmd := &cobra.Command{
		Use:   "metadata-json",
		Short: "Call the MetadataJSON view method on a PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if poolIDRaw == "" {
				return fmt.Errorf("--pool-id argument not specified")
			}
			poolID = new(big.Int)
			poolID.SetString(poolIDRaw, 0)

			if poolRaw == "" {
				return fmt.Errorf("--pool argument not specified")
			} else if strings.HasPrefix(poolRaw, "@") {
				filename := strings.TrimPrefix(poolRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(poolRaw), &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			if positionRaw == "" {
				return fmt.Errorf("--position argument not specified")
			} else if strings.HasPrefix(positionRaw, "@") {
				filename := strings.TrimPrefix(positionRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(positionRaw), &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewPositionMetadata(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := PositionMetadataCallerSession{
				Contract: &contract.PositionMetadataCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.MetadataJSON(
				poolID,
				pool,
				positionTokenID,
				position,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&poolIDRaw, "pool-id", "", "pool-id argument")
	cmd.Flags().StringVar(&poolRaw, "pool", "", "pool argument (StakingPool)")
	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")
	cmd.Flags().StringVar(&positionRaw, "position", "", "position argument (Position)")

	return cmd
}

var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the POSITION_METADATA_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the POSITION_METADATA_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("POSITION_METADATA_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func CreatePositionMetadataCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "position-metadata",
		Short: "Interact with the PositionMetadata contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	cmdDeployPositionMetadata := CreatePositionMetadataDeploymentCommand()
	cmdDeployPositionMetadata.GroupID = DeployGroup.ID
	cmd.AddCommand(cmdDeployPositionMetadata)

	cmdViewMetadata := CreateMetadataCommand()
	cmdViewMetadata.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewMetadata)
	cmdViewMetadataBytes := CreateMetadataBytesCommand()
	cmdViewMetadataBytes.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewMetadataBytes)
	cmdViewMetadataJSON := CreateMetadataJsonCommand()
	cmdViewMetadataJSON.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewMetadataJSON)

	return cmd
}
