// This file was generated by seer: https://github.com/moonstream-to/seer.
// seer version: 0.1.20
// seer command: seer evm generate --package PositionMetadata --cli --struct PositionMetadata --output bindings/PositionMetadata/PositionMetadata.go
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package PositionMetadata

import (
	"errors"
	"math/big"
	"strings"

	"context"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"

	// Reference imports to suppress errors if they are not otherwise used.
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/spf13/cobra"
	"golang.org/x/term"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// Position is an auto generated low-level Go binding around an user-defined struct.
type Position struct {
	PoolID             *big.Int
	AmountOrTokenID    *big.Int
	StakeTimestamp     *big.Int
	UnstakeInitiatedAt *big.Int
}

// StakingPool is an auto generated low-level Go binding around an user-defined struct.
type StakingPool struct {
	Administrator   common.Address
	TokenType       *big.Int
	TokenAddress    common.Address
	TokenID         *big.Int
	Transferable    bool
	LockupSeconds   *big.Int
	CooldownSeconds *big.Int
}

// PositionMetadataMetaData contains all meta data concerning the PositionMetadata contract.
var PositionMetadataMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeInitiatedAt\",\"type\":\"uint256\"}],\"internalType\":\"structPosition\",\"name\":\"position\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structStakingPool\",\"name\":\"pool\",\"type\":\"tuple\"}],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeInitiatedAt\",\"type\":\"uint256\"}],\"internalType\":\"structPosition\",\"name\":\"position\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structStakingPool\",\"name\":\"pool\",\"type\":\"tuple\"}],\"name\":\"metadataBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeInitiatedAt\",\"type\":\"uint256\"}],\"internalType\":\"structPosition\",\"name\":\"position\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structStakingPool\",\"name\":\"pool\",\"type\":\"tuple\"}],\"name\":\"metadataJSON\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561001057600080fd5b5061120c806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063239bdf6c14610046578063721ac18a146100765780637b2f34ff146100a6575b600080fd5b610060600480360381019061005b91906108c4565b6100d6565b60405161006d9190610997565b60405180910390f35b610090600480360381019061008b91906108c4565b6100ec565b60405161009d9190610a0e565b60405180910390f35b6100c060048036038101906100bb91906108c4565b61025c565b6040516100cd9190610997565b60405180910390f35b60606100e38484846100ec565b90509392505050565b606060006100f985610299565b6040516020016101099190610b9c565b6040516020818303038152906040529050806101288560000151610299565b604051602001610139929190610cce565b6040516020818303038152906040529050806102d1846020015114610176576040518060600160405280602781526020016111b060279139610190565b604051806060016040528060298152602001611187602991395b61019d8660200151610299565b6040516020016101af93929190610d54565b6040516020818303038152906040529050806101ce8560400151610299565b6040516020016101df929190610e59565b60405160208183030381529060405290508061020d8460a0015186604001516102089190610ec2565b610299565b60405160200161021e929190610f8e565b6040516020818303038152906040529050806040516020016102409190611014565b6040516020818303038152906040529050809150509392505050565b606061027161026c8585856100ec565b610367565b6040516020016102819190611082565b60405160208183030381529060405290509392505050565b6060600060016102a8846104d9565b01905060008167ffffffffffffffff8111156102c7576102c6610687565b5b6040519080825280601f01601f1916602001820160405280156102f95781602001600182028036833780820191505090505b509050600082602001820190505b60011561035c578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a85816103505761034f6110a4565b5b04945060008503610307575b819350505050919050565b60606000825103610389576040518060200160405280600081525090506104d4565b600060405180606001604052806040815260200161114760409139905060006003600285516103b89190610ec2565b6103c291906110d3565b60046103ce9190611104565b67ffffffffffffffff8111156103e7576103e6610687565b5b6040519080825280601f01601f1916602001820160405280156104195781602001600182028036833780820191505090505b50905060018201602082018586518701602081018051600082525b8284101561048f576003840193508351603f8160121c168701518653600186019550603f81600c1c168701518653600186019550603f8160061c168701518653600186019550603f8116870151865360018601955050610434565b80825260038a5106600181146104ac57600281146104bf576104c7565b603d6001870353603d60028703536104c7565b603d60018703535b5050505050505080925050505b919050565b600080600090507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310610537577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161052d5761052c6110a4565b5b0492506040810190505b6d04ee2d6d415b85acef81000000008310610574576d04ee2d6d415b85acef8100000000838161056a576105696110a4565b5b0492506020810190505b662386f26fc1000083106105a357662386f26fc100008381610599576105986110a4565b5b0492506010810190505b6305f5e10083106105cc576305f5e10083816105c2576105c16110a4565b5b0492506008810190505b61271083106105f15761271083816105e7576105e66110a4565b5b0492506004810190505b60648310610614576064838161060a576106096110a4565b5b0492506002810190505b600a8310610623576001810190505b80915050919050565b6000604051905090565b600080fd5b6000819050919050565b61064e8161063b565b811461065957600080fd5b50565b60008135905061066b81610645565b92915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6106bf82610676565b810181811067ffffffffffffffff821117156106de576106dd610687565b5b80604052505050565b60006106f161062c565b90506106fd82826106b6565b919050565b60006080828403121561071857610717610671565b5b61072260806106e7565b905060006107328482850161065c565b60008301525060206107468482850161065c565b602083015250604061075a8482850161065c565b604083015250606061076e8482850161065c565b60608301525092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006107a58261077a565b9050919050565b6107b58161079a565b81146107c057600080fd5b50565b6000813590506107d2816107ac565b92915050565b60008115159050919050565b6107ed816107d8565b81146107f857600080fd5b50565b60008135905061080a816107e4565b92915050565b600060e0828403121561082657610825610671565b5b61083060e06106e7565b90506000610840848285016107c3565b60008301525060206108548482850161065c565b6020830152506040610868848285016107c3565b604083015250606061087c8482850161065c565b6060830152506080610890848285016107fb565b60808301525060a06108a48482850161065c565b60a08301525060c06108b88482850161065c565b60c08301525092915050565b600080600061018084860312156108de576108dd610636565b5b60006108ec8682870161065c565b93505060206108fd86828701610702565b92505060a061090e86828701610810565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b60005b83811015610952578082015181840152602081019050610937565b60008484015250505050565b600061096982610918565b6109738185610923565b9350610983818560208601610934565b61098c81610676565b840191505092915050565b600060208201905081810360008301526109b1818461095e565b905092915050565b600081519050919050565b600082825260208201905092915050565b60006109e0826109b9565b6109ea81856109c4565b93506109fa818560208601610934565b610a0381610676565b840191505092915050565b60006020820190508181036000830152610a2881846109d5565b905092915050565b600081905092915050565b7f7b22746f6b656e5f6964223a2200000000000000000000000000000000000000600082015250565b6000610a71600d83610a30565b9150610a7c82610a3b565b600d82019050919050565b6000610a9282610918565b610a9c8185610a30565b9350610aac818560208601610934565b80840191505092915050565b7f222c22696d616765223a202268747470733a2f2f6261646765732e6d6f6f6e7360008201527f747265616d2e746f2f746573742f7374616b696e675f6c6f676f2e706e672200602082015250565b6000610b14603f83610a30565b9150610b1f82610ab8565b603f82019050919050565b7f2c22726573756c745f76657273696f6e223a312c22617474726962757465732260008201527f3a205b0000000000000000000000000000000000000000000000000000000000602082015250565b6000610b86602383610a30565b9150610b9182610b2a565b602382019050919050565b6000610ba782610a64565b9150610bb38284610a87565b9150610bbe82610b07565b9150610bc982610b79565b915081905092915050565b600081905092915050565b6000610bea826109b9565b610bf48185610bd4565b9350610c04818560208601610934565b80840191505092915050565b7f7b2274726169745f74797065223a22506f6f6c204944222c2276616c7565223a60008201527f2200000000000000000000000000000000000000000000000000000000000000602082015250565b6000610c6c602183610a30565b9150610c7782610c10565b602182019050919050565b7f227d000000000000000000000000000000000000000000000000000000000000600082015250565b6000610cb8600283610a30565b9150610cc382610c82565b600282019050919050565b6000610cda8285610bdf565b9150610ce582610c5f565b9150610cf18284610a87565b9150610cfc82610cab565b91508190509392505050565b7f2c00000000000000000000000000000000000000000000000000000000000000600082015250565b6000610d3e600183610a30565b9150610d4982610d08565b600182019050919050565b6000610d608286610bdf565b9150610d6b82610d31565b9150610d778285610a87565b9150610d838284610a87565b9150610d8e82610cab565b9150819050949350505050565b7f2c7b22646973706c61795f74797065223a226e756d626572222c22747261697460008201527f5f74797065223a225374616b6564206174222c2276616c7565223a0000000000602082015250565b6000610df7603b83610a30565b9150610e0282610d9b565b603b82019050919050565b7f7d00000000000000000000000000000000000000000000000000000000000000600082015250565b6000610e43600183610a30565b9150610e4e82610e0d565b600182019050919050565b6000610e658285610bdf565b9150610e7082610dea565b9150610e7c8284610a87565b9150610e8782610e36565b91508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610ecd8261063b565b9150610ed88361063b565b9250828201905080821115610ef057610eef610e93565b5b92915050565b7f2c7b22646973706c61795f74797065223a226e756d626572222c22747261697460008201527f5f74797065223a224c6f636b75702065787069726573206174222c2276616c7560208201527f65223a0000000000000000000000000000000000000000000000000000000000604082015250565b6000610f78604383610a30565b9150610f8382610ef6565b604382019050919050565b6000610f9a8285610bdf565b9150610fa582610f6b565b9150610fb18284610a87565b9150610fbc82610e36565b91508190509392505050565b7f5d7d000000000000000000000000000000000000000000000000000000000000600082015250565b6000610ffe600283610a30565b915061100982610fc8565b600282019050919050565b60006110208284610bdf565b915061102b82610ff1565b915081905092915050565b7f646174613a6170706c69636174696f6e2f6a736f6e3b6261736536342c000000600082015250565b600061106c601d83610a30565b915061107782611036565b601d82019050919050565b600061108d8261105f565b91506110998284610a87565b915081905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006110de8261063b565b91506110e98361063b565b9250826110f9576110f86110a4565b5b828204905092915050565b600061110f8261063b565b915061111a8361063b565b92508282026111288161063b565b9150828204841483151761113f5761113e610e93565b5b509291505056fe4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392b2f7b2274726169745f74797065223a225374616b656420746f6b656e204944222c2276616c7565223a227b2274726169745f74797065223a225374616b656420616d6f756e74222c2276616c7565223a22a26469706673582212201ba45e687da3ccb740445486ef2bae091e5dc525110f352658f7c961a8db363e64736f6c63430008180033",
}

// PositionMetadataABI is the input ABI used to generate the binding from.
// Deprecated: Use PositionMetadataMetaData.ABI instead.
var PositionMetadataABI = PositionMetadataMetaData.ABI

// PositionMetadataBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PositionMetadataMetaData.Bin instead.
var PositionMetadataBin = PositionMetadataMetaData.Bin

// DeployPositionMetadata deploys a new Ethereum contract, binding an instance of PositionMetadata to it.
func DeployPositionMetadata(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *PositionMetadata, error) {
	parsed, err := PositionMetadataMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PositionMetadataBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PositionMetadata{PositionMetadataCaller: PositionMetadataCaller{contract: contract}, PositionMetadataTransactor: PositionMetadataTransactor{contract: contract}, PositionMetadataFilterer: PositionMetadataFilterer{contract: contract}}, nil
}

// PositionMetadata is an auto generated Go binding around an Ethereum contract.
type PositionMetadata struct {
	PositionMetadataCaller     // Read-only binding to the contract
	PositionMetadataTransactor // Write-only binding to the contract
	PositionMetadataFilterer   // Log filterer for contract events
}

// PositionMetadataCaller is an auto generated read-only Go binding around an Ethereum contract.
type PositionMetadataCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionMetadataTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PositionMetadataTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionMetadataFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PositionMetadataFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PositionMetadataSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PositionMetadataSession struct {
	Contract     *PositionMetadata // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PositionMetadataCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PositionMetadataCallerSession struct {
	Contract *PositionMetadataCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// PositionMetadataTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PositionMetadataTransactorSession struct {
	Contract     *PositionMetadataTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// PositionMetadataRaw is an auto generated low-level Go binding around an Ethereum contract.
type PositionMetadataRaw struct {
	Contract *PositionMetadata // Generic contract binding to access the raw methods on
}

// PositionMetadataCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PositionMetadataCallerRaw struct {
	Contract *PositionMetadataCaller // Generic read-only contract binding to access the raw methods on
}

// PositionMetadataTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PositionMetadataTransactorRaw struct {
	Contract *PositionMetadataTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPositionMetadata creates a new instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadata(address common.Address, backend bind.ContractBackend) (*PositionMetadata, error) {
	contract, err := bindPositionMetadata(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PositionMetadata{PositionMetadataCaller: PositionMetadataCaller{contract: contract}, PositionMetadataTransactor: PositionMetadataTransactor{contract: contract}, PositionMetadataFilterer: PositionMetadataFilterer{contract: contract}}, nil
}

// NewPositionMetadataCaller creates a new read-only instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadataCaller(address common.Address, caller bind.ContractCaller) (*PositionMetadataCaller, error) {
	contract, err := bindPositionMetadata(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PositionMetadataCaller{contract: contract}, nil
}

// NewPositionMetadataTransactor creates a new write-only instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadataTransactor(address common.Address, transactor bind.ContractTransactor) (*PositionMetadataTransactor, error) {
	contract, err := bindPositionMetadata(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PositionMetadataTransactor{contract: contract}, nil
}

// NewPositionMetadataFilterer creates a new log filterer instance of PositionMetadata, bound to a specific deployed contract.
func NewPositionMetadataFilterer(address common.Address, filterer bind.ContractFilterer) (*PositionMetadataFilterer, error) {
	contract, err := bindPositionMetadata(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PositionMetadataFilterer{contract: contract}, nil
}

// bindPositionMetadata binds a generic wrapper to an already deployed contract.
func bindPositionMetadata(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := PositionMetadataMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PositionMetadata *PositionMetadataRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PositionMetadata.Contract.PositionMetadataCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PositionMetadata *PositionMetadataRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PositionMetadata.Contract.PositionMetadataTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PositionMetadata *PositionMetadataRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PositionMetadata.Contract.PositionMetadataTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PositionMetadata *PositionMetadataCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PositionMetadata.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PositionMetadata *PositionMetadataTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PositionMetadata.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PositionMetadata *PositionMetadataTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PositionMetadata.Contract.contract.Transact(opts, method, params...)
}

// Metadata is a free data retrieval call binding the contract method 0x7b2f34ff.
//
// Solidity: function metadata(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataCaller) Metadata(opts *bind.CallOpts, positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	var out []interface{}
	err := _PositionMetadata.contract.Call(opts, &out, "metadata", positionTokenID, position, pool)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Metadata is a free data retrieval call binding the contract method 0x7b2f34ff.
//
// Solidity: function metadata(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataSession) Metadata(positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	return _PositionMetadata.Contract.Metadata(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

// Metadata is a free data retrieval call binding the contract method 0x7b2f34ff.
//
// Solidity: function metadata(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataCallerSession) Metadata(positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	return _PositionMetadata.Contract.Metadata(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

// MetadataBytes is a free data retrieval call binding the contract method 0x721ac18a.
//
// Solidity: function metadataBytes(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(bytes)
func (_PositionMetadata *PositionMetadataCaller) MetadataBytes(opts *bind.CallOpts, positionTokenID *big.Int, position Position, pool StakingPool) ([]byte, error) {
	var out []interface{}
	err := _PositionMetadata.contract.Call(opts, &out, "metadataBytes", positionTokenID, position, pool)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// MetadataBytes is a free data retrieval call binding the contract method 0x721ac18a.
//
// Solidity: function metadataBytes(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(bytes)
func (_PositionMetadata *PositionMetadataSession) MetadataBytes(positionTokenID *big.Int, position Position, pool StakingPool) ([]byte, error) {
	return _PositionMetadata.Contract.MetadataBytes(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

// MetadataBytes is a free data retrieval call binding the contract method 0x721ac18a.
//
// Solidity: function metadataBytes(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(bytes)
func (_PositionMetadata *PositionMetadataCallerSession) MetadataBytes(positionTokenID *big.Int, position Position, pool StakingPool) ([]byte, error) {
	return _PositionMetadata.Contract.MetadataBytes(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

// MetadataJSON is a free data retrieval call binding the contract method 0x239bdf6c.
//
// Solidity: function metadataJSON(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataCaller) MetadataJSON(opts *bind.CallOpts, positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	var out []interface{}
	err := _PositionMetadata.contract.Call(opts, &out, "metadataJSON", positionTokenID, position, pool)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// MetadataJSON is a free data retrieval call binding the contract method 0x239bdf6c.
//
// Solidity: function metadataJSON(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataSession) MetadataJSON(positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	return _PositionMetadata.Contract.MetadataJSON(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

// MetadataJSON is a free data retrieval call binding the contract method 0x239bdf6c.
//
// Solidity: function metadataJSON(uint256 positionTokenID, (uint256,uint256,uint256,uint256) position, (address,uint256,address,uint256,bool,uint256,uint256) pool) pure returns(string)
func (_PositionMetadata *PositionMetadataCallerSession) MetadataJSON(positionTokenID *big.Int, position Position, pool StakingPool) (string, error) {
	return _PositionMetadata.Contract.MetadataJSON(&_PositionMetadata.CallOpts, positionTokenID, position, pool)
}

func CreatePositionMetadataDeploymentCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint

	cmd := &cobra.Command{
		Use:   "deploy",
		Short: "Deploy a new PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			address, deploymentTransaction, _, deploymentErr := DeployPositionMetadata(
				transactionOpts,
				client,
			)
			if deploymentErr != nil {
				return deploymentErr
			}

			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					Data: deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")

	return cmd
}

func CreateMetadataCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var positionTokenID *big.Int
	var positionTokenIDRaw string
	var position Position
	var positionRaw string
	var pool StakingPool
	var poolRaw string

	var capture0 string

	cmd := &cobra.Command{
		Use:   "metadata",
		Short: "Call the Metadata view method on a PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			if positionRaw == "" {
				return fmt.Errorf("--position argument not specified")
			} else if strings.HasPrefix(positionRaw, "@") {
				filename := strings.TrimPrefix(positionRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(positionRaw), &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if poolRaw == "" {
				return fmt.Errorf("--pool argument not specified")
			} else if strings.HasPrefix(poolRaw, "@") {
				filename := strings.TrimPrefix(poolRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(poolRaw), &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewPositionMetadata(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := PositionMetadataCallerSession{
				Contract: &contract.PositionMetadataCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Metadata(
				positionTokenID,
				position,
				pool,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")
	cmd.Flags().StringVar(&positionRaw, "position", "", "position argument (Position)")
	cmd.Flags().StringVar(&poolRaw, "pool", "", "pool argument (StakingPool)")

	return cmd
}
func CreateMetadataBytesCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var positionTokenID *big.Int
	var positionTokenIDRaw string
	var position Position
	var positionRaw string
	var pool StakingPool
	var poolRaw string

	var capture0 []byte

	cmd := &cobra.Command{
		Use:   "metadata-bytes",
		Short: "Call the MetadataBytes view method on a PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			if positionRaw == "" {
				return fmt.Errorf("--position argument not specified")
			} else if strings.HasPrefix(positionRaw, "@") {
				filename := strings.TrimPrefix(positionRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(positionRaw), &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if poolRaw == "" {
				return fmt.Errorf("--pool argument not specified")
			} else if strings.HasPrefix(poolRaw, "@") {
				filename := strings.TrimPrefix(poolRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(poolRaw), &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewPositionMetadata(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := PositionMetadataCallerSession{
				Contract: &contract.PositionMetadataCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.MetadataBytes(
				positionTokenID,
				position,
				pool,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")
	cmd.Flags().StringVar(&positionRaw, "position", "", "position argument (Position)")
	cmd.Flags().StringVar(&poolRaw, "pool", "", "pool argument (StakingPool)")

	return cmd
}
func CreateMetadataJsonCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var positionTokenID *big.Int
	var positionTokenIDRaw string
	var position Position
	var positionRaw string
	var pool StakingPool
	var poolRaw string

	var capture0 string

	cmd := &cobra.Command{
		Use:   "metadata-json",
		Short: "Call the MetadataJSON view method on a PositionMetadata contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			if positionRaw == "" {
				return fmt.Errorf("--position argument not specified")
			} else if strings.HasPrefix(positionRaw, "@") {
				filename := strings.TrimPrefix(positionRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(positionRaw), &position)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if poolRaw == "" {
				return fmt.Errorf("--pool argument not specified")
			} else if strings.HasPrefix(poolRaw, "@") {
				filename := strings.TrimPrefix(poolRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(poolRaw), &pool)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewPositionMetadata(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := PositionMetadataCallerSession{
				Contract: &contract.PositionMetadataCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.MetadataJSON(
				positionTokenID,
				position,
				pool,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")
	cmd.Flags().StringVar(&positionRaw, "position", "", "position argument (Position)")
	cmd.Flags().StringVar(&poolRaw, "pool", "", "pool argument (StakingPool)")

	return cmd
}

var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the POSITION_METADATA_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the POSITION_METADATA_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("POSITION_METADATA_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func CreatePositionMetadataCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "position-metadata",
		Short: "Interact with the PositionMetadata contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	cmdDeployPositionMetadata := CreatePositionMetadataDeploymentCommand()
	cmdDeployPositionMetadata.GroupID = DeployGroup.ID
	cmd.AddCommand(cmdDeployPositionMetadata)

	cmdViewMetadata := CreateMetadataCommand()
	cmdViewMetadata.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewMetadata)
	cmdViewMetadataBytes := CreateMetadataBytesCommand()
	cmdViewMetadataBytes.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewMetadataBytes)
	cmdViewMetadataJSON := CreateMetadataJsonCommand()
	cmdViewMetadataJSON.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewMetadataJSON)

	return cmd
}
