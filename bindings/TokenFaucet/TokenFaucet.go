// This file was generated by seer: https://github.com/moonstream-to/seer.
// seer version: 0.1.3
// seer command: seer evm generate --package TokenFaucet --cli --struct TokenFaucet --output bindings/TokenFaucet/TokenFaucet.go
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package TokenFaucet

import (
	"errors"
	"math/big"
	"strings"

	"context"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"

	// Reference imports to suppress errors if they are not otherwise used.
	"encoding/hex"
	"fmt"
	"os"
	"time"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/spf13/cobra"
	"golang.org/x/term"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// TokenFaucetMetaData contains all meta data concerning the TokenFaucet contract.
var TokenFaucetMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_TOKEN_ADDRESS\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_FAUCET_AMOUNT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_FAUCET_BLOCK_INTERVAL\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFaucetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFaucetBlockInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLastClaimedBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_FAUCET_AMOUNT\",\"type\":\"uint256\"}],\"name\":\"setFaucetAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_FAUCET_BLOCK_INTERVAL\",\"type\":\"uint256\"}],\"name\":\"setFaucetBlockInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_TOKEN_ADDRESS\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60806040523480156200001157600080fd5b5060405162000e6038038062000e608339818101604052810190620000379190620003fe565b82600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603620000ad5760006040517f1e4fbdf7000000000000000000000000000000000000000000000000000000008152600401620000a4919062000481565b60405180910390fd5b620000be816200012960201b60201c565b5083600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081600281905550806003819055506200011f83620001ed60201b60201c565b505050506200049e565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b620001fd6200028660201b60201c565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603620002725760006040517f1e4fbdf700000000000000000000000000000000000000000000000000000000815260040162000269919062000481565b60405180910390fd5b62000283816200012960201b60201c565b50565b620002966200032860201b60201c565b73ffffffffffffffffffffffffffffffffffffffff16620002bc6200033060201b60201c565b73ffffffffffffffffffffffffffffffffffffffff16146200032657620002e86200032860201b60201c565b6040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016200031d919062000481565b60405180910390fd5b565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006200038b826200035e565b9050919050565b6200039d816200037e565b8114620003a957600080fd5b50565b600081519050620003bd8162000392565b92915050565b6000819050919050565b620003d881620003c3565b8114620003e457600080fd5b50565b600081519050620003f881620003cd565b92915050565b600080600080608085870312156200041b576200041a62000359565b5b60006200042b87828801620003ac565b94505060206200043e87828801620003ac565b93505060406200045187828801620003e7565b92505060606200046487828801620003e7565b91505092959194509250565b6200047b816200037e565b82525050565b600060208201905062000498600083018462000470565b92915050565b6109b280620004ae6000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c8063715018a611610071578063715018a61461016757806381d2fd9c146101715780638da5cb5b1461018d578063bc1cb46b146101ab578063ed27e1f1146101c9578063f2fde38b146101f9576100b4565b806310fe9ae8146100b957806315942e29146100d757806326a4e8d2146100f35780633aecd0e31461010f5780634e71d92d1461013f5780636da8f09314610149575b600080fd5b6100c1610215565b6040516100ce9190610743565b60405180910390f35b6100f160048036038101906100ec9190610799565b61023f565b005b61010d600480360381019061010891906107f2565b610251565b005b610129600480360381019061012491906107f2565b61029d565b604051610136919061082e565b60405180910390f35b610147610327565b005b610151610453565b60405161015e919061082e565b60405180910390f35b61016f61045d565b005b61018b60048036038101906101869190610799565b610471565b005b610195610483565b6040516101a29190610743565b60405180910390f35b6101b36104ac565b6040516101c0919061082e565b60405180910390f35b6101e360048036038101906101de91906107f2565b6104b6565b6040516101f0919061082e565b60405180910390f35b610213600480360381019061020e91906107f2565b6104ff565b005b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b610247610585565b8060038190555050565b610259610585565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60006102a761060c565b73ffffffffffffffffffffffffffffffffffffffff166370a08231836040518263ffffffff1660e01b81526004016102df9190610743565b602060405180830381865afa1580156102fc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610320919061085e565b9050919050565b6000439050600354600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461037991906108ba565b811161038457600080fd5b61038c61060c565b73ffffffffffffffffffffffffffffffffffffffff1663a9059cbb336002546040518363ffffffff1660e01b81526004016103c89291906108ee565b6020604051808303816000875af11580156103e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061040b919061094f565b5080600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555050565b6000600354905090565b610465610585565b61046f6000610636565b565b610479610585565b8060028190555050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b6000600254905090565b6000600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b610507610585565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16036105795760006040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526004016105709190610743565b60405180910390fd5b61058281610636565b50565b61058d6106fa565b73ffffffffffffffffffffffffffffffffffffffff166105ab610483565b73ffffffffffffffffffffffffffffffffffffffff161461060a576105ce6106fa565b6040517f118cdaa70000000000000000000000000000000000000000000000000000000081526004016106019190610743565b60405180910390fd5b565b6000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b600033905090565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061072d82610702565b9050919050565b61073d81610722565b82525050565b60006020820190506107586000830184610734565b92915050565b600080fd5b6000819050919050565b61077681610763565b811461078157600080fd5b50565b6000813590506107938161076d565b92915050565b6000602082840312156107af576107ae61075e565b5b60006107bd84828501610784565b91505092915050565b6107cf81610722565b81146107da57600080fd5b50565b6000813590506107ec816107c6565b92915050565b6000602082840312156108085761080761075e565b5b6000610816848285016107dd565b91505092915050565b61082881610763565b82525050565b6000602082019050610843600083018461081f565b92915050565b6000815190506108588161076d565b92915050565b6000602082840312156108745761087361075e565b5b600061088284828501610849565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006108c582610763565b91506108d083610763565b92508282019050808211156108e8576108e761088b565b5b92915050565b60006040820190506109036000830185610734565b610910602083018461081f565b9392505050565b60008115159050919050565b61092c81610917565b811461093757600080fd5b50565b60008151905061094981610923565b92915050565b6000602082840312156109655761096461075e565b5b60006109738482850161093a565b9150509291505056fea264697066735822122050f1311b069e59b75620647a9fd420553ba1ddba2605ed97b6140fc4ce66c8d464736f6c63430008180033",
}

// TokenFaucetABI is the input ABI used to generate the binding from.
// Deprecated: Use TokenFaucetMetaData.ABI instead.
var TokenFaucetABI = TokenFaucetMetaData.ABI

// TokenFaucetBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use TokenFaucetMetaData.Bin instead.
var TokenFaucetBin = TokenFaucetMetaData.Bin

// DeployTokenFaucet deploys a new Ethereum contract, binding an instance of TokenFaucet to it.
func DeployTokenFaucet(auth *bind.TransactOpts, backend bind.ContractBackend, _TOKEN_ADDRESS common.Address, _owner common.Address, _FAUCET_AMOUNT *big.Int, _FAUCET_BLOCK_INTERVAL *big.Int) (common.Address, *types.Transaction, *TokenFaucet, error) {
	parsed, err := TokenFaucetMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(TokenFaucetBin), backend, _TOKEN_ADDRESS, _owner, _FAUCET_AMOUNT, _FAUCET_BLOCK_INTERVAL)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &TokenFaucet{TokenFaucetCaller: TokenFaucetCaller{contract: contract}, TokenFaucetTransactor: TokenFaucetTransactor{contract: contract}, TokenFaucetFilterer: TokenFaucetFilterer{contract: contract}}, nil
}

// TokenFaucet is an auto generated Go binding around an Ethereum contract.
type TokenFaucet struct {
	TokenFaucetCaller     // Read-only binding to the contract
	TokenFaucetTransactor // Write-only binding to the contract
	TokenFaucetFilterer   // Log filterer for contract events
}

// TokenFaucetCaller is an auto generated read-only Go binding around an Ethereum contract.
type TokenFaucetCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenFaucetTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TokenFaucetTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenFaucetFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TokenFaucetFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenFaucetSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TokenFaucetSession struct {
	Contract     *TokenFaucet      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TokenFaucetCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TokenFaucetCallerSession struct {
	Contract *TokenFaucetCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// TokenFaucetTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TokenFaucetTransactorSession struct {
	Contract     *TokenFaucetTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// TokenFaucetRaw is an auto generated low-level Go binding around an Ethereum contract.
type TokenFaucetRaw struct {
	Contract *TokenFaucet // Generic contract binding to access the raw methods on
}

// TokenFaucetCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TokenFaucetCallerRaw struct {
	Contract *TokenFaucetCaller // Generic read-only contract binding to access the raw methods on
}

// TokenFaucetTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TokenFaucetTransactorRaw struct {
	Contract *TokenFaucetTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTokenFaucet creates a new instance of TokenFaucet, bound to a specific deployed contract.
func NewTokenFaucet(address common.Address, backend bind.ContractBackend) (*TokenFaucet, error) {
	contract, err := bindTokenFaucet(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TokenFaucet{TokenFaucetCaller: TokenFaucetCaller{contract: contract}, TokenFaucetTransactor: TokenFaucetTransactor{contract: contract}, TokenFaucetFilterer: TokenFaucetFilterer{contract: contract}}, nil
}

// NewTokenFaucetCaller creates a new read-only instance of TokenFaucet, bound to a specific deployed contract.
func NewTokenFaucetCaller(address common.Address, caller bind.ContractCaller) (*TokenFaucetCaller, error) {
	contract, err := bindTokenFaucet(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TokenFaucetCaller{contract: contract}, nil
}

// NewTokenFaucetTransactor creates a new write-only instance of TokenFaucet, bound to a specific deployed contract.
func NewTokenFaucetTransactor(address common.Address, transactor bind.ContractTransactor) (*TokenFaucetTransactor, error) {
	contract, err := bindTokenFaucet(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TokenFaucetTransactor{contract: contract}, nil
}

// NewTokenFaucetFilterer creates a new log filterer instance of TokenFaucet, bound to a specific deployed contract.
func NewTokenFaucetFilterer(address common.Address, filterer bind.ContractFilterer) (*TokenFaucetFilterer, error) {
	contract, err := bindTokenFaucet(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TokenFaucetFilterer{contract: contract}, nil
}

// bindTokenFaucet binds a generic wrapper to an already deployed contract.
func bindTokenFaucet(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := TokenFaucetMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenFaucet *TokenFaucetRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TokenFaucet.Contract.TokenFaucetCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenFaucet *TokenFaucetRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenFaucet.Contract.TokenFaucetTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenFaucet *TokenFaucetRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenFaucet.Contract.TokenFaucetTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenFaucet *TokenFaucetCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _TokenFaucet.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenFaucet *TokenFaucetTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenFaucet.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenFaucet *TokenFaucetTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenFaucet.Contract.contract.Transact(opts, method, params...)
}

// GetFaucetAmount is a free data retrieval call binding the contract method 0xbc1cb46b.
//
// Solidity: function getFaucetAmount() view returns(uint256)
func (_TokenFaucet *TokenFaucetCaller) GetFaucetAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _TokenFaucet.contract.Call(opts, &out, "getFaucetAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetFaucetAmount is a free data retrieval call binding the contract method 0xbc1cb46b.
//
// Solidity: function getFaucetAmount() view returns(uint256)
func (_TokenFaucet *TokenFaucetSession) GetFaucetAmount() (*big.Int, error) {
	return _TokenFaucet.Contract.GetFaucetAmount(&_TokenFaucet.CallOpts)
}

// GetFaucetAmount is a free data retrieval call binding the contract method 0xbc1cb46b.
//
// Solidity: function getFaucetAmount() view returns(uint256)
func (_TokenFaucet *TokenFaucetCallerSession) GetFaucetAmount() (*big.Int, error) {
	return _TokenFaucet.Contract.GetFaucetAmount(&_TokenFaucet.CallOpts)
}

// GetFaucetBlockInterval is a free data retrieval call binding the contract method 0x6da8f093.
//
// Solidity: function getFaucetBlockInterval() view returns(uint256)
func (_TokenFaucet *TokenFaucetCaller) GetFaucetBlockInterval(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _TokenFaucet.contract.Call(opts, &out, "getFaucetBlockInterval")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetFaucetBlockInterval is a free data retrieval call binding the contract method 0x6da8f093.
//
// Solidity: function getFaucetBlockInterval() view returns(uint256)
func (_TokenFaucet *TokenFaucetSession) GetFaucetBlockInterval() (*big.Int, error) {
	return _TokenFaucet.Contract.GetFaucetBlockInterval(&_TokenFaucet.CallOpts)
}

// GetFaucetBlockInterval is a free data retrieval call binding the contract method 0x6da8f093.
//
// Solidity: function getFaucetBlockInterval() view returns(uint256)
func (_TokenFaucet *TokenFaucetCallerSession) GetFaucetBlockInterval() (*big.Int, error) {
	return _TokenFaucet.Contract.GetFaucetBlockInterval(&_TokenFaucet.CallOpts)
}

// GetLastClaimedBlock is a free data retrieval call binding the contract method 0xed27e1f1.
//
// Solidity: function getLastClaimedBlock(address _address) view returns(uint256)
func (_TokenFaucet *TokenFaucetCaller) GetLastClaimedBlock(opts *bind.CallOpts, _address common.Address) (*big.Int, error) {
	var out []interface{}
	err := _TokenFaucet.contract.Call(opts, &out, "getLastClaimedBlock", _address)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetLastClaimedBlock is a free data retrieval call binding the contract method 0xed27e1f1.
//
// Solidity: function getLastClaimedBlock(address _address) view returns(uint256)
func (_TokenFaucet *TokenFaucetSession) GetLastClaimedBlock(_address common.Address) (*big.Int, error) {
	return _TokenFaucet.Contract.GetLastClaimedBlock(&_TokenFaucet.CallOpts, _address)
}

// GetLastClaimedBlock is a free data retrieval call binding the contract method 0xed27e1f1.
//
// Solidity: function getLastClaimedBlock(address _address) view returns(uint256)
func (_TokenFaucet *TokenFaucetCallerSession) GetLastClaimedBlock(_address common.Address) (*big.Int, error) {
	return _TokenFaucet.Contract.GetLastClaimedBlock(&_TokenFaucet.CallOpts, _address)
}

// GetTokenAddress is a free data retrieval call binding the contract method 0x10fe9ae8.
//
// Solidity: function getTokenAddress() view returns(address)
func (_TokenFaucet *TokenFaucetCaller) GetTokenAddress(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TokenFaucet.contract.Call(opts, &out, "getTokenAddress")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetTokenAddress is a free data retrieval call binding the contract method 0x10fe9ae8.
//
// Solidity: function getTokenAddress() view returns(address)
func (_TokenFaucet *TokenFaucetSession) GetTokenAddress() (common.Address, error) {
	return _TokenFaucet.Contract.GetTokenAddress(&_TokenFaucet.CallOpts)
}

// GetTokenAddress is a free data retrieval call binding the contract method 0x10fe9ae8.
//
// Solidity: function getTokenAddress() view returns(address)
func (_TokenFaucet *TokenFaucetCallerSession) GetTokenAddress() (common.Address, error) {
	return _TokenFaucet.Contract.GetTokenAddress(&_TokenFaucet.CallOpts)
}

// GetTokenBalance is a free data retrieval call binding the contract method 0x3aecd0e3.
//
// Solidity: function getTokenBalance(address _address) view returns(uint256)
func (_TokenFaucet *TokenFaucetCaller) GetTokenBalance(opts *bind.CallOpts, _address common.Address) (*big.Int, error) {
	var out []interface{}
	err := _TokenFaucet.contract.Call(opts, &out, "getTokenBalance", _address)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetTokenBalance is a free data retrieval call binding the contract method 0x3aecd0e3.
//
// Solidity: function getTokenBalance(address _address) view returns(uint256)
func (_TokenFaucet *TokenFaucetSession) GetTokenBalance(_address common.Address) (*big.Int, error) {
	return _TokenFaucet.Contract.GetTokenBalance(&_TokenFaucet.CallOpts, _address)
}

// GetTokenBalance is a free data retrieval call binding the contract method 0x3aecd0e3.
//
// Solidity: function getTokenBalance(address _address) view returns(uint256)
func (_TokenFaucet *TokenFaucetCallerSession) GetTokenBalance(_address common.Address) (*big.Int, error) {
	return _TokenFaucet.Contract.GetTokenBalance(&_TokenFaucet.CallOpts, _address)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TokenFaucet *TokenFaucetCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _TokenFaucet.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TokenFaucet *TokenFaucetSession) Owner() (common.Address, error) {
	return _TokenFaucet.Contract.Owner(&_TokenFaucet.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_TokenFaucet *TokenFaucetCallerSession) Owner() (common.Address, error) {
	return _TokenFaucet.Contract.Owner(&_TokenFaucet.CallOpts)
}

// Claim is a paid mutator transaction binding the contract method 0x4e71d92d.
//
// Solidity: function claim() returns()
func (_TokenFaucet *TokenFaucetTransactor) Claim(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenFaucet.contract.Transact(opts, "claim")
}

// Claim is a paid mutator transaction binding the contract method 0x4e71d92d.
//
// Solidity: function claim() returns()
func (_TokenFaucet *TokenFaucetSession) Claim() (*types.Transaction, error) {
	return _TokenFaucet.Contract.Claim(&_TokenFaucet.TransactOpts)
}

// Claim is a paid mutator transaction binding the contract method 0x4e71d92d.
//
// Solidity: function claim() returns()
func (_TokenFaucet *TokenFaucetTransactorSession) Claim() (*types.Transaction, error) {
	return _TokenFaucet.Contract.Claim(&_TokenFaucet.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TokenFaucet *TokenFaucetTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenFaucet.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TokenFaucet *TokenFaucetSession) RenounceOwnership() (*types.Transaction, error) {
	return _TokenFaucet.Contract.RenounceOwnership(&_TokenFaucet.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_TokenFaucet *TokenFaucetTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _TokenFaucet.Contract.RenounceOwnership(&_TokenFaucet.TransactOpts)
}

// SetFaucetAmount is a paid mutator transaction binding the contract method 0x81d2fd9c.
//
// Solidity: function setFaucetAmount(uint256 _FAUCET_AMOUNT) returns()
func (_TokenFaucet *TokenFaucetTransactor) SetFaucetAmount(opts *bind.TransactOpts, _FAUCET_AMOUNT *big.Int) (*types.Transaction, error) {
	return _TokenFaucet.contract.Transact(opts, "setFaucetAmount", _FAUCET_AMOUNT)
}

// SetFaucetAmount is a paid mutator transaction binding the contract method 0x81d2fd9c.
//
// Solidity: function setFaucetAmount(uint256 _FAUCET_AMOUNT) returns()
func (_TokenFaucet *TokenFaucetSession) SetFaucetAmount(_FAUCET_AMOUNT *big.Int) (*types.Transaction, error) {
	return _TokenFaucet.Contract.SetFaucetAmount(&_TokenFaucet.TransactOpts, _FAUCET_AMOUNT)
}

// SetFaucetAmount is a paid mutator transaction binding the contract method 0x81d2fd9c.
//
// Solidity: function setFaucetAmount(uint256 _FAUCET_AMOUNT) returns()
func (_TokenFaucet *TokenFaucetTransactorSession) SetFaucetAmount(_FAUCET_AMOUNT *big.Int) (*types.Transaction, error) {
	return _TokenFaucet.Contract.SetFaucetAmount(&_TokenFaucet.TransactOpts, _FAUCET_AMOUNT)
}

// SetFaucetBlockInterval is a paid mutator transaction binding the contract method 0x15942e29.
//
// Solidity: function setFaucetBlockInterval(uint256 _FAUCET_BLOCK_INTERVAL) returns()
func (_TokenFaucet *TokenFaucetTransactor) SetFaucetBlockInterval(opts *bind.TransactOpts, _FAUCET_BLOCK_INTERVAL *big.Int) (*types.Transaction, error) {
	return _TokenFaucet.contract.Transact(opts, "setFaucetBlockInterval", _FAUCET_BLOCK_INTERVAL)
}

// SetFaucetBlockInterval is a paid mutator transaction binding the contract method 0x15942e29.
//
// Solidity: function setFaucetBlockInterval(uint256 _FAUCET_BLOCK_INTERVAL) returns()
func (_TokenFaucet *TokenFaucetSession) SetFaucetBlockInterval(_FAUCET_BLOCK_INTERVAL *big.Int) (*types.Transaction, error) {
	return _TokenFaucet.Contract.SetFaucetBlockInterval(&_TokenFaucet.TransactOpts, _FAUCET_BLOCK_INTERVAL)
}

// SetFaucetBlockInterval is a paid mutator transaction binding the contract method 0x15942e29.
//
// Solidity: function setFaucetBlockInterval(uint256 _FAUCET_BLOCK_INTERVAL) returns()
func (_TokenFaucet *TokenFaucetTransactorSession) SetFaucetBlockInterval(_FAUCET_BLOCK_INTERVAL *big.Int) (*types.Transaction, error) {
	return _TokenFaucet.Contract.SetFaucetBlockInterval(&_TokenFaucet.TransactOpts, _FAUCET_BLOCK_INTERVAL)
}

// SetTokenAddress is a paid mutator transaction binding the contract method 0x26a4e8d2.
//
// Solidity: function setTokenAddress(address _TOKEN_ADDRESS) returns()
func (_TokenFaucet *TokenFaucetTransactor) SetTokenAddress(opts *bind.TransactOpts, _TOKEN_ADDRESS common.Address) (*types.Transaction, error) {
	return _TokenFaucet.contract.Transact(opts, "setTokenAddress", _TOKEN_ADDRESS)
}

// SetTokenAddress is a paid mutator transaction binding the contract method 0x26a4e8d2.
//
// Solidity: function setTokenAddress(address _TOKEN_ADDRESS) returns()
func (_TokenFaucet *TokenFaucetSession) SetTokenAddress(_TOKEN_ADDRESS common.Address) (*types.Transaction, error) {
	return _TokenFaucet.Contract.SetTokenAddress(&_TokenFaucet.TransactOpts, _TOKEN_ADDRESS)
}

// SetTokenAddress is a paid mutator transaction binding the contract method 0x26a4e8d2.
//
// Solidity: function setTokenAddress(address _TOKEN_ADDRESS) returns()
func (_TokenFaucet *TokenFaucetTransactorSession) SetTokenAddress(_TOKEN_ADDRESS common.Address) (*types.Transaction, error) {
	return _TokenFaucet.Contract.SetTokenAddress(&_TokenFaucet.TransactOpts, _TOKEN_ADDRESS)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TokenFaucet *TokenFaucetTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _TokenFaucet.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TokenFaucet *TokenFaucetSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TokenFaucet.Contract.TransferOwnership(&_TokenFaucet.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_TokenFaucet *TokenFaucetTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _TokenFaucet.Contract.TransferOwnership(&_TokenFaucet.TransactOpts, newOwner)
}

// TokenFaucetOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the TokenFaucet contract.
type TokenFaucetOwnershipTransferredIterator struct {
	Event *TokenFaucetOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *TokenFaucetOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(TokenFaucetOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(TokenFaucetOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *TokenFaucetOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *TokenFaucetOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// TokenFaucetOwnershipTransferred represents a OwnershipTransferred event raised by the TokenFaucet contract.
type TokenFaucetOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TokenFaucet *TokenFaucetFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*TokenFaucetOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TokenFaucet.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &TokenFaucetOwnershipTransferredIterator{contract: _TokenFaucet.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TokenFaucet *TokenFaucetFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *TokenFaucetOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _TokenFaucet.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(TokenFaucetOwnershipTransferred)
				if err := _TokenFaucet.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_TokenFaucet *TokenFaucetFilterer) ParseOwnershipTransferred(log types.Log) (*TokenFaucetOwnershipTransferred, error) {
	event := new(TokenFaucetOwnershipTransferred)
	if err := _TokenFaucet.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

func CreateTokenFaucetDeploymentCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint

	var TOKEN_ADDRESS common.Address
	var TOKEN_ADDRESSRaw string
	var owner common.Address
	var ownerRaw string
	var FAUCET_AMOUNT *big.Int
	var FAUCET_AMOUNTRaw string
	var FAUCET_BLOCK_INTERVAL *big.Int
	var FAUCET_BLOCK_INTERVALRaw string

	cmd := &cobra.Command{
		Use:   "deploy",
		Short: "Deploy a new TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if TOKEN_ADDRESSRaw == "" {
				return fmt.Errorf("--token-address argument not specified")
			} else if !common.IsHexAddress(TOKEN_ADDRESSRaw) {
				return fmt.Errorf("--token-address argument is not a valid Ethereum address")
			}
			TOKEN_ADDRESS = common.HexToAddress(TOKEN_ADDRESSRaw)

			if ownerRaw == "" {
				return fmt.Errorf("--owner argument not specified")
			} else if !common.IsHexAddress(ownerRaw) {
				return fmt.Errorf("--owner argument is not a valid Ethereum address")
			}
			owner = common.HexToAddress(ownerRaw)

			if FAUCET_AMOUNTRaw == "" {
				return fmt.Errorf("--faucet-amount argument not specified")
			}
			FAUCET_AMOUNT = new(big.Int)
			FAUCET_AMOUNT.SetString(FAUCET_AMOUNTRaw, 0)

			if FAUCET_BLOCK_INTERVALRaw == "" {
				return fmt.Errorf("--faucet-block-interval argument not specified")
			}
			FAUCET_BLOCK_INTERVAL = new(big.Int)
			FAUCET_BLOCK_INTERVAL.SetString(FAUCET_BLOCK_INTERVALRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			address, deploymentTransaction, _, deploymentErr := DeployTokenFaucet(
				transactionOpts,
				client,
				TOKEN_ADDRESS,
				owner,
				FAUCET_AMOUNT,
				FAUCET_BLOCK_INTERVAL,
			)
			if deploymentErr != nil {
				return deploymentErr
			}

			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					Data: deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")

	cmd.Flags().StringVar(&TOKEN_ADDRESSRaw, "token-address", "", "token-address argument")
	cmd.Flags().StringVar(&ownerRaw, "owner", "", "owner argument")
	cmd.Flags().StringVar(&FAUCET_AMOUNTRaw, "faucet-amount", "", "faucet-amount argument")
	cmd.Flags().StringVar(&FAUCET_BLOCK_INTERVALRaw, "faucet-block-interval", "", "faucet-block-interval argument")

	return cmd
}

func CreateGetFaucetBlockIntervalCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "get-faucet-block-interval",
		Short: "Call the GetFaucetBlockInterval view method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := TokenFaucetCallerSession{
				Contract: &contract.TokenFaucetCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetFaucetBlockInterval()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateGetLastClaimedBlockCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var address common.Address
	var addressRaw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "get-last-claimed-block",
		Short: "Call the GetLastClaimedBlock view method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if addressRaw == "" {
				return fmt.Errorf("--address argument not specified")
			} else if !common.IsHexAddress(addressRaw) {
				return fmt.Errorf("--address argument is not a valid Ethereum address")
			}
			address = common.HexToAddress(addressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := TokenFaucetCallerSession{
				Contract: &contract.TokenFaucetCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetLastClaimedBlock(
				address,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&addressRaw, "address", "", "address argument")

	return cmd
}
func CreateGetTokenAddressCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 common.Address

	cmd := &cobra.Command{
		Use:   "get-token-address",
		Short: "Call the GetTokenAddress view method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := TokenFaucetCallerSession{
				Contract: &contract.TokenFaucetCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetTokenAddress()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.Hex())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateGetTokenBalanceCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var address common.Address
	var addressRaw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "get-token-balance",
		Short: "Call the GetTokenBalance view method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if addressRaw == "" {
				return fmt.Errorf("--address argument not specified")
			} else if !common.IsHexAddress(addressRaw) {
				return fmt.Errorf("--address argument is not a valid Ethereum address")
			}
			address = common.HexToAddress(addressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := TokenFaucetCallerSession{
				Contract: &contract.TokenFaucetCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetTokenBalance(
				address,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&addressRaw, "address", "", "address argument")

	return cmd
}
func CreateOwnerCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 common.Address

	cmd := &cobra.Command{
		Use:   "owner",
		Short: "Call the Owner view method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := TokenFaucetCallerSession{
				Contract: &contract.TokenFaucetCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Owner()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.Hex())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateGetFaucetAmountCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "get-faucet-amount",
		Short: "Call the GetFaucetAmount view method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := TokenFaucetCallerSession{
				Contract: &contract.TokenFaucetCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetFaucetAmount()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}

func CreateClaimCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	cmd := &cobra.Command{
		Use:   "claim",
		Short: "Execute the Claim method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := TokenFaucetTransactorSession{
				Contract:     &contract.TokenFaucetTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.Claim()
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	return cmd
}
func CreateRenounceOwnershipCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	cmd := &cobra.Command{
		Use:   "renounce-ownership",
		Short: "Execute the RenounceOwnership method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := TokenFaucetTransactorSession{
				Contract:     &contract.TokenFaucetTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.RenounceOwnership()
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	return cmd
}
func CreateSetFaucetAmountCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var FAUCET_AMOUNT *big.Int
	var FAUCET_AMOUNTRaw string

	cmd := &cobra.Command{
		Use:   "set-faucet-amount",
		Short: "Execute the SetFaucetAmount method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if FAUCET_AMOUNTRaw == "" {
				return fmt.Errorf("--faucet-amount argument not specified")
			}
			FAUCET_AMOUNT = new(big.Int)
			FAUCET_AMOUNT.SetString(FAUCET_AMOUNTRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := TokenFaucetTransactorSession{
				Contract:     &contract.TokenFaucetTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.SetFaucetAmount(
				FAUCET_AMOUNT,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&FAUCET_AMOUNTRaw, "faucet-amount", "", "faucet-amount argument")

	return cmd
}
func CreateSetFaucetBlockIntervalCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var FAUCET_BLOCK_INTERVAL *big.Int
	var FAUCET_BLOCK_INTERVALRaw string

	cmd := &cobra.Command{
		Use:   "set-faucet-block-interval",
		Short: "Execute the SetFaucetBlockInterval method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if FAUCET_BLOCK_INTERVALRaw == "" {
				return fmt.Errorf("--faucet-block-interval argument not specified")
			}
			FAUCET_BLOCK_INTERVAL = new(big.Int)
			FAUCET_BLOCK_INTERVAL.SetString(FAUCET_BLOCK_INTERVALRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := TokenFaucetTransactorSession{
				Contract:     &contract.TokenFaucetTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.SetFaucetBlockInterval(
				FAUCET_BLOCK_INTERVAL,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&FAUCET_BLOCK_INTERVALRaw, "faucet-block-interval", "", "faucet-block-interval argument")

	return cmd
}
func CreateSetTokenAddressCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var TOKEN_ADDRESS common.Address
	var TOKEN_ADDRESSRaw string

	cmd := &cobra.Command{
		Use:   "set-token-address",
		Short: "Execute the SetTokenAddress method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if TOKEN_ADDRESSRaw == "" {
				return fmt.Errorf("--token-address argument not specified")
			} else if !common.IsHexAddress(TOKEN_ADDRESSRaw) {
				return fmt.Errorf("--token-address argument is not a valid Ethereum address")
			}
			TOKEN_ADDRESS = common.HexToAddress(TOKEN_ADDRESSRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := TokenFaucetTransactorSession{
				Contract:     &contract.TokenFaucetTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.SetTokenAddress(
				TOKEN_ADDRESS,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&TOKEN_ADDRESSRaw, "token-address", "", "token-address argument")

	return cmd
}
func CreateTransferOwnershipCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var newOwner common.Address
	var newOwnerRaw string

	cmd := &cobra.Command{
		Use:   "transfer-ownership",
		Short: "Execute the TransferOwnership method on a TokenFaucet contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if newOwnerRaw == "" {
				return fmt.Errorf("--new-owner argument not specified")
			} else if !common.IsHexAddress(newOwnerRaw) {
				return fmt.Errorf("--new-owner argument is not a valid Ethereum address")
			}
			newOwner = common.HexToAddress(newOwnerRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewTokenFaucet(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := TokenFaucetTransactorSession{
				Contract:     &contract.TokenFaucetTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.TransferOwnership(
				newOwner,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&newOwnerRaw, "new-owner", "", "new-owner argument")

	return cmd
}

var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the TOKEN_FAUCET_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the TOKEN_FAUCET_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("TOKEN_FAUCET_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func CreateTokenFaucetCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "token-faucet",
		Short: "Interact with the TokenFaucet contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	cmdDeployTokenFaucet := CreateTokenFaucetDeploymentCommand()
	cmdDeployTokenFaucet.GroupID = DeployGroup.ID
	cmd.AddCommand(cmdDeployTokenFaucet)

	cmdViewGetFaucetBlockInterval := CreateGetFaucetBlockIntervalCommand()
	cmdViewGetFaucetBlockInterval.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetFaucetBlockInterval)
	cmdViewGetLastClaimedBlock := CreateGetLastClaimedBlockCommand()
	cmdViewGetLastClaimedBlock.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetLastClaimedBlock)
	cmdViewGetTokenAddress := CreateGetTokenAddressCommand()
	cmdViewGetTokenAddress.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetTokenAddress)
	cmdViewGetTokenBalance := CreateGetTokenBalanceCommand()
	cmdViewGetTokenBalance.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetTokenBalance)
	cmdViewOwner := CreateOwnerCommand()
	cmdViewOwner.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewOwner)
	cmdViewGetFaucetAmount := CreateGetFaucetAmountCommand()
	cmdViewGetFaucetAmount.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetFaucetAmount)

	cmdTransactClaim := CreateClaimCommand()
	cmdTransactClaim.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactClaim)
	cmdTransactRenounceOwnership := CreateRenounceOwnershipCommand()
	cmdTransactRenounceOwnership.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactRenounceOwnership)
	cmdTransactSetFaucetAmount := CreateSetFaucetAmountCommand()
	cmdTransactSetFaucetAmount.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSetFaucetAmount)
	cmdTransactSetFaucetBlockInterval := CreateSetFaucetBlockIntervalCommand()
	cmdTransactSetFaucetBlockInterval.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSetFaucetBlockInterval)
	cmdTransactSetTokenAddress := CreateSetTokenAddressCommand()
	cmdTransactSetTokenAddress.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSetTokenAddress)
	cmdTransactTransferOwnership := CreateTransferOwnershipCommand()
	cmdTransactTransferOwnership.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactTransferOwnership)

	return cmd
}
